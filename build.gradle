allprojects {
    group = "edu.ucar"
    version = '4.6.0-SNAPSHOT'
}

// Due to a Gradle limitation, we cannot externalize this buildscript block into a script plugin. However, we can
// exploit the fact that dependencies specified in a parent's buildscript block are visible to all children.
// Thus, as long as we declare all plugins here, no child needs its own buildscript block. See
// http://forums.gradle.org/gradle/topics/how_do_i_include_buildscript_block_from_external_gradle_script#reply_9303244
buildscript {
    apply from: "$rootDir/gradle/dependencies.gradle"

    repositories {
        jcenter()
    }
    dependencies {
        classpath libraries["gretty"]
        classpath libraries["shadow"]
        classpath libraries["coveralls-gradle-plugin"]
    }
}

apply from: "$rootDir/gradle/coverage.gradle"

task jacocoRootReport(type: JacocoReport, group: 'Coverage reports') {
    description = 'Generates an aggregate report from all subprojects'

    // By default, JacocoReport will be skipped if ANY of its executionData are non-existent: http://goo.gl/pHuwyg
    // This is a problem: we don't know which executionData we have until configuration time. So, we're temporarily
    // assigning an empty collection (leaving it null causes an exception), and assigning the real values later.
    executionData = files()

    // Causes jacocoRootReport to always be executed. This is necessary because JacocoReport uses executionData as one
    // of its Inputs, and by assigning an empty collection above, the normal UP-TO-DATE machinery has been subverted.
    // As a result, jacocoRootReport can't properly determine when subprojects have generated new coverage data
    // (it thinks its executionData Inputs are always UP-TO-DATE). We'll try to detect those changes manually below.
    outputs.upToDateWhen { false }  // Evaluated at configuration time (onlyIf{} is evaluated at execution time)

    doFirst {
        Closure isExtendedByJacoco = { Task task -> task.extensions.findByType(JacocoTaskExtension) }
        Collection<Task> tasksExtendedByJacoco = subprojects*.tasks*.matching(isExtendedByJacoco).flatten()
        Collection<File> exeData = tasksExtendedByJacoco*.jacoco*.destinationFile

        // Add all subproject executionData that actually exist.
        executionData = files(exeData.findAll { it.exists() })

        // Skip task if NO executionData exists. This is how JacocoReport ought to work in the first place.
        if (executionData.isEmpty()) {
            throw new StopExecutionException("SKIPPING $name: no execution data found.")
        }

        boolean allOutputsExist = outputs.files.every { it.exists() }
        boolean anyJacocoTaskDidWork = tasksExtendedByJacoco.any { it.didWork }

        // Skip task if all outputs exist (previously generated) and no Jacoco tasks did any work (meaning that the
        // Inputs didn't change). This manual UP-TO-DATE checking is certainly inferior to Gradle's built-in machinery
        // (this doesn't detect modifications to outputs, for example), but it's good enough given the circumstances.
        // The long-term solution may be to reimplement JacocoReport with the troublesome elements removed.
        if (allOutputsExist && !anyJacocoTaskDidWork) {
            throw new StopExecutionException("SKIPPING $name: outputs already exist and no Jacoco tasks did work.")
        }
    }
}

apply plugin: "com.github.kt3k.coveralls"

tasks.coveralls {
    group = 'Coverage reports'
    description = 'Uploads the aggregated coverage report to Coveralls'
    dependsOn jacocoRootReport
}

coveralls {
    jacocoReportPath = tasks.jacocoRootReport.reports.xml.destination
    sourceDirs = tasks.jacocoRootReport.sourceDirectories
}

apply plugin: "base"  // Gives us the "clean" task for removing jacocoRootReport's output.
