allprojects {
    group = "edu.ucar"
    version = '4.6.0-SNAPSHOT'
}

// Pulls contents into this script. Subprojects inherit the properties and methods defined by their parent.
apply from: "$rootDir/gradle/dependencies.gradle"

apply from: "$rootDir/gradle/publishing.gradle"

task wrapper(type: Wrapper) {
    gradleVersion = '2.3'
}



// Have to evaluate the child projects before we can refer to their "test" and "jacocoTestReport" tasks below.
evaluationDependsOnChildren()

apply plugin: "jacoco"

task jacocoRootReport(type: JacocoReport, group: 'Coverage reports') {
    description = 'Generates an aggregate report from all subprojects'
    dependsOn getTasksByName("test", true)  // All subproject test tasks.
//    dependsOn subprojects*.tasks.withType(Test)

    // Source sets are added by the java plugin, and not all subprojects have that applied. ":dap4" is one.
    Collection<Project> projectsWithSourceSets = subprojects.findAll { it.hasProperty("sourceSets") }

    // The signature of the method we're calling is: void sourceSets(SourceSet... sourceSets)
    // However, the spread-dot operator has given us a list. We use the spread operator to convert:
    // http://docs.groovy-lang.org/latest/html/documentation/#_spreading_method_arguments
    sourceSets(*(projectsWithSourceSets*.sourceSets*.main))

    // We won't know which subprojects generate executionData until the execution phase.
    // However, the JacocoReport ctor will throw an exception if we leave this null.
    // So, assign an empty collection temporarily.
    executionData = files()

    reports {
        html.enabled = true
        html.destination "${buildDir}/reports/jacoco"
        xml.enabled = true
        csv.enabled = false
    }

    // JacocoReport will be skipped if ANY of its executionData are non-existent, so we must filter out those
    // that didn't get created during test execution.
    // See https://gist.github.com/aalmiray/e6f54aa4b3803be0bcac#file-build-gradle
    outputs.upToDateWhen { false }

    doFirst {
        // Jacoco reports are added by the jacoco plugin, and not all subprojects have that applied.
        Collection<Project> projectsWithJacoco = subprojects.findAll { it.hasProperty("jacocoTestReport") }

        // Add all subproject executionData that actually exists.
        Collection<File> allExecutionData = projectsWithJacoco*.jacocoTestReport*.executionData*.files.flatten()
        executionData = files(allExecutionData.findAll { it.exists() })

        // Skip task if NO executionData exists. This is how JacocoReport ought to work in the first place.
        if (executionData.isEmpty()) {
            throw new StopExecutionException("No execution data found for $name.")
        }
    }
}
