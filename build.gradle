allprojects {
    group = "edu.ucar"
    version = '4.6.0-SNAPSHOT'
}

// Due to a Gradle limitation, we cannot externalize this buildscript block into a script plugin. However, we can
// exploit the fact that dependencies specified in a parent's buildscript block are visible to all children.
// Thus, as long as we declare all plugins here, no child needs its own buildscript block. See
// http://forums.gradle.org/gradle/topics/how_do_i_include_buildscript_block_from_external_gradle_script#reply_9303244
buildscript {
    apply from: "$rootDir/gradle/dependencies.gradle"

    repositories {
        jcenter()
    }
    dependencies {
        classpath libraries["gretty"]
        classpath libraries["shadow"]
        classpath libraries["coveralls-gradle-plugin"]
    }
}

apply from: "$rootDir/gradle/coverage.gradle"

task jacocoRootReport(type: JacocoReport, group: 'Coverage reports') {
    description = 'Generates an aggregate report from all subprojects'

    // By default, JacocoReport will be skipped if ANY of its executionData are non-existent: http://goo.gl/pHuwyg
    // This is a problem: we don't know which executionData we have until configuration time. So, we're temporarily
    // assigning an empty collection (leaving it null causes an exception), and assigning the real values later.
    executionData = files()

    // Causes jacocoRootReport to always be executed. This is necessary because JacocoReport uses executionData as one
    // of its Inputs, and by assigning an empty collection above, the normal UP-TO-DATE machinery has been subverted.
    // As a result, jacocoRootReport can't properly determine when subprojects have generated new coverage data
    // (it thinks its executionData Inputs are always UP-TO-DATE). We'll try to detect those changes manually below.
    outputs.upToDateWhen { false }  // Evaluated at configuration time (onlyIf{} is evaluated at execution time)

    doFirst {
        Closure isExtendedByJacoco = { Task task -> task.extensions.findByType(JacocoTaskExtension) }
        Collection<Task> tasksExtendedByJacoco = subprojects*.tasks*.matching(isExtendedByJacoco).flatten()
        Collection<File> exeData = tasksExtendedByJacoco*.jacoco*.destinationFile

        // Add all subproject executionData that actually exist.
        executionData = files(exeData.findAll { it.exists() })

        // Skip task if NO executionData exists. This is how JacocoReport ought to work in the first place.
        if (executionData.isEmpty()) {
            throw new StopExecutionException("SKIPPING $name: no execution data found.")
        }

        boolean allOutputsExist = outputs.files.every { it.exists() }
        boolean anyJacocoTaskDidWork = tasksExtendedByJacoco.any { it.didWork }

        // Skip task if all outputs exist (previously generated) and no Jacoco tasks did any work (meaning that the
        // Inputs didn't change). This manual UP-TO-DATE checking is certainly inferior to Gradle's built-in machinery
        // (this doesn't detect modifications to outputs, for example), but it's good enough given the circumstances.
        // The long-term solution may be to reimplement JacocoReport with the troublesome elements removed.
        if (allOutputsExist && !anyJacocoTaskDidWork) {
            throw new StopExecutionException("SKIPPING $name: outputs already exist and no Jacoco tasks did work.")
        }
    }
}

apply plugin: "com.github.kt3k.coveralls"

// Ordinarily, I'd be able to configure the "coveralls" task by using the "coveralls(Closure)" dynamic method added to
// Project when the above plugin is applied. However, the plugin also adds an extension with the same name (see
// http://goo.gl/GVE4v6). As a result, Project now has TWO dynamic methods with the "coveralls(Closure)" signature.
//
// Which method takes precedence: the one that configures the extension or the one that configures the task? I can't
// find a definitive answer, but the Gradle docs (http://goo.gl/KPXLpf) seem to indicate that the extension wins
// (it appears earlier in the list--hardly definitive, I know).
//
// Operating under this assumption, we must explicitly indicate that we are configuring the "coveralls" task.
tasks.coveralls {
    group = 'Coverage reports'
    description = 'Uploads the aggregated coverage report to Coveralls'
    dependsOn jacocoRootReport

    // This task logs the entire coveralls.io JSON payload (~27 MB) to the INFO log level. We don't want to see it.
    logging.level = LogLevel.LIFECYCLE

    // tasks.jacocoRootReport.sourceDirectories won't be ready until the very end of the evaluation phase. So, to avoid
    // grabbing "unfinished" properties, we'll just configure this task at execution time. That's okay for this task
    // because it doesn't declare any Inputs or Outputs and therefore can never be considered UP-TO-DATE.
    doFirst {
        // We want to add the COVERALLS_REPO_TOKEN entry, but coveralls.env is an UnmodifiableMap.
        // So, create a copy of env, add our entry, then replace the old map with it.
        // FIXME: In production, COVERALLS_REPO_TOKEN should be an environment variable.
        Map<String, String> envCopy = new HashMap<>(env)
        envCopy["COVERALLS_REPO_TOKEN"] = "DX6UcqPqzkY5CtAjC99qYHNEnVZGNDLOd"
        env = envCopy

        // Configure the "coveralls" extension. These properties only appear on the extension, not the task.
        coveralls {
            jacocoReportPath = tasks.jacocoRootReport.reports.xml.destination
            sourceDirs = tasks.jacocoRootReport.sourceDirectories.files.collect { it.getPath() }
        }
    }
}

apply plugin: "base"  // Gives us the "clean" task for removing jacocoRootReport's output.
