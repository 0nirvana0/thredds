allprojects {
    // The jacoco plugin adds the jacocoTestReport task, but only if the java plugin is already applied.
    apply plugin: "jacoco"

    tasks.withType(Test) {
        // Add the execution data that Jacoco generates as a task output.
        outputs.file jacoco.destinationFile
    }

    // Will apply to ":<subproject>:jacocoTestReport", ":it:integrationTestReport", ":rootJacocoReport", etc.
    tasks.withType(JacocoReport) {
        // Include all Test tasks from this project and any subprojects.
        dependsOn allprojects*.tasks*.withType(Test)

        Collection<Project> javaProjects = rootProject.subprojects.findAll { it.pluginManager.hasPlugin("java") }
        List<SourceSet> mainSourceSets = javaProjects*.sourceSets*.main

        sourceDirectories = files(mainSourceSets*.allSource*.srcDirs)
        classDirectories = files(mainSourceSets*.output)

        reports {
            xml.enabled = true
            html.enabled = true
            csv.enabled = false
        }
    }
}

///////////////////////////////////////////////// Root /////////////////////////////////////////////////

task rootJacocoReport(type: JacocoReport, group: 'Reports') {
    description = 'Generates an aggregate coverage report from all subprojects'

    // By default, JacocoReport will be skipped if ANY of its executionData are non-existent: http://goo.gl/pHuwyg
    // This is a problem: we don't know which data we have until execution time. So, we're temporarily assigning an
    // empty collection (leaving it null causes an exception), and assigning the real values later.
    executionData = files()

    // Causes rootJacocoReport to always be executed. This is necessary because JacocoReport uses executionData as one
    // of its Inputs, and by assigning an empty collection above, the normal UP-TO-DATE machinery has been subverted.
    // As a result, rootJacocoReport can't properly determine when subprojects have generated new coverage data
    // (it thinks its executionData Inputs are always UP-TO-DATE). We'll try to detect those changes manually below.
    outputs.upToDateWhen { false }  // Evaluated at configuration time (onlyIf{} is evaluated at execution time)

    doFirst {
        Closure isExtendedByJacoco = { Task task -> task.extensions.findByType(JacocoTaskExtension) }
        Collection<Task> tasksExtendedByJacoco = subprojects*.tasks*.matching(isExtendedByJacoco).flatten()
        Collection<File> exeData = tasksExtendedByJacoco*.jacoco*.destinationFile

        // Add all subproject executionData that actually exist.
        executionData = files(exeData.findAll { it.exists() })

        // Skip task if NO executionData exists. This is how JacocoReport ought to work in the first place.
        if (executionData.isEmpty()) {
            throw new StopExecutionException("SKIPPING $name: no execution data found.")
        }

        boolean allOutputsExist = outputs.files.every { it.exists() }
        boolean anyJacocoTaskDidWork = tasksExtendedByJacoco.any { it.didWork }

        // Skip task if all outputs exist (previously generated) and no Jacoco tasks did any work (meaning that the
        // Inputs didn't change). This manual UP-TO-DATE checking is certainly inferior to Gradle's built-in machinery
        // (this doesn't detect modifications to outputs, for example), but it's good enough given the circumstances.
        // The long-term solution may be to reimplement JacocoReport with the troublesome elements removed.
        if (allOutputsExist && !anyJacocoTaskDidWork) {
            throw new StopExecutionException("SKIPPING $name: outputs already exist and no Jacoco tasks did work.")
        }
    }
}

apply plugin: "base"  // Gives us the "clean" task for removing rootJacocoReport's output.


buildscript {
    apply from: "$rootDir/gradle/dependencies.gradle"

    repositories {
        jcenter()
    }
    dependencies {
        classpath libraries["coveralls-gradle-plugin"]
    }
}

apply plugin: "com.github.kt3k.coveralls"
import org.kt3k.gradle.plugin.coveralls.CoverallsTask
import org.gradle.api.internal.plugins.ExtensionContainerInternal

task coverallsReport(type: CoverallsTask, group: 'Reports', dependsOn: rootJacocoReport) {
    description = 'Uploads the aggregate coverage report to Coveralls'

    // This task logs the entire coveralls.io JSON payload (~27 MB) to the INFO log level. We don't want to see it.
    logging.level = LogLevel.LIFECYCLE

    // We want to add the COVERALLS_REPO_TOKEN entry, but coveralls.env is an UnmodifiableMap.
    // So, create a copy of env, add our entry, then replace the old map with it.
    // FIXME: In production, COVERALLS_REPO_TOKEN should be an environment variable.
    Map<String, String> envCopy = new HashMap<>(env)
    envCopy["COVERALLS_REPO_TOKEN"] = "viswgi0kF5EOgHJXEb58OrOZzToIbi0oJ"
    env = envCopy


    ExtensionContainerInternal exts = (ExtensionContainerInternal) extensions
    println "===extensions==="
    exts.each {
        println "\t$it"
    }

    // Configure the "coveralls" extension. These properties only appear on the extension, not the task.
    coveralls {
        jacocoReportPath = tasks.rootJacocoReport.reports.xml.destination
        sourceDirs = tasks.rootJacocoReport.sourceDirectories.files.collect { it.getPath() }
    }



//    configure(extensions.getByType(CoverallsPluginExtension.class)) {
//        jacocoReportPath = tasks.rootJacocoReport.reports.xml.destination
//        sourceDirs = tasks.rootJacocoReport.sourceDirectories.files.collect { it.getPath() }
//    }
}
