subprojects {
    apply from: "$rootDir/gradle/dependencies.gradle"

    dependencies {
        testCompile libraries["junit"]

        if (name != "cdm") {
            // Applying this to "cdm" creates a circular dependency.
            testCompile project(path: ':cdm', configuration: 'testArtifacts')
        }
    }

    // Add an SLF4J binding to testRuntime, if necessary.
    afterEvaluate {
        if (testRuntimeHasDepNamed("slf4j-api")) {
            if (!testRuntimeHasDepNamed("slf4j-jdk14") && !testRuntimeHasDepNamed("log4j-slf4j-impl")) {
                dependencies.testRuntime libraries["slf4j-jdk14"]  // Default binding.
            }
        }
    }
}

boolean testRuntimeHasDepNamed(String depName) {
    try {
        // Groovy truth: empty collections are coerced to false.
        configurations.getByName('testRuntime').allDependencies.findAll { it.name == depName }
    } catch (UnknownConfigurationException e) {  // Project did not have a configuration named 'testRuntime'.
        logger.debug e.message
        false
    }
}

ext.contentRootKey = "tds.content.root.path"
ext.contentRootVal = null  // To be set in isContentRootAvailable()

ext.testdataDirKey = "unidata.testdata.path"
ext.testdataDirVal = null  // To be assigned in ___

// Process test exclusions.
gradle.taskGraph.whenReady { TaskExecutionGraph taskGraph ->
    Collection<Task> testTasks = taskGraph.allTasks.findAll { it instanceof Test }
    if (!testTasks) {
        return  // We're not running any tests.
    }

    // These appear to be the only environment variables that Jenkins defines: http://goo.gl/iCh08k
    // Is there a better way to detect Jenkins?
    boolean isJenkins = System.env['JENKINS_URL']  // We only care if prop is defined, not its actual value.

    boolean isTravis = System.env['TRAVIS']

    // We only want to write these log messages once, which is why we don't have them in the "testTasks*.configure{}"
    // block below.

    if (isTravis) {
        logger.warn "Skipping all NotTravis tests: detected that we're running in the Travis environment."
    }

    boolean isContentRootAvailable = isContentRootAvailable()
    if (!isContentRootAvailable && !isJenkins) {
        logger.warn "Skipping all NeedsContentRoot tests."
    }

    boolean isCdmUnitTestDirAvailable = isCdmUnitTestDirAvailable()
    if (!isCdmUnitTestDirAvailable && !isJenkins) {
        logger.warn "Skipping all NeedsCdmUnitTest tests."
    }

    testTasks*.configure {
        systemProperties = System.properties

        useJUnit {
            if (isTravis) {
                ignoreFailures false  // On Travis, abort the build if any tests fail.
                excludeCategories 'ucar.unidata.test.util.NotTravis'
            } else {
                ignoreFailures true  // In every other environment, don't let test failures abort the build.
            }

            if (isContentRootAvailable) {
                systemProperty contentRootKey, contentRootVal   // Propagate to Gradle Test Executor.
            } else {
                // As the code stands, we really need to assign *some* value to this property.
                // Don't try a sensible default; we want to know about the misconfiguration.
                // Instead, give it something that corresponds to a directory that surely does not exist.
                systemProperty contentRootKey, "/NO/$contentRootKey/FOUND/"

                if (!isJenkins) {  // Never exclude any tests when running on Jenkins.
                    excludeCategories 'ucar.unidata.test.util.NeedsContentRoot'

                    if (path == ":it:integrationTest") {
                        logger.warn "Skipping all integration tests (task \'$path\'): " +
                                "\'$contentRootKey\' property not defined."

                        // We can't stand up a functioning TDS test instance without a valid content root,
                        // so disable the integration test task altogether.
                        setEnabled false
                    }
                }
            }

            if (isCdmUnitTestDirAvailable) {
                systemProperty testdataDirKey, testdataDirVal
            } else {
                systemProperty testdataDirKey, "/NO/$testdataDirKey/FOUND/"

                if (!isJenkins) {
                    excludeCategories 'ucar.unidata.test.util.NeedsCdmUnitTest'
                }
            }
        }
    }
}

// TODO: There's a lot of redundant code here. These two methods could be replaced by "isPropertyValidDirectory()".
// I could set system properties in there as well.

boolean isContentRootAvailable() {
    if (!hasProperty(contentRootKey)) {
        logger.warn "\'$contentRootKey\' property not defined."
        return false
    } else {
        contentRootVal = property(contentRootKey) as String;

        if (!new File(contentRootVal).isDirectory()) {
            logger.warn "\'$contentRootVal\' directory not found."
            return false
        } else {
            return true
        }
    }
}

boolean isCdmUnitTestDirAvailable() {
    if (!hasProperty(testdataDirKey)) {
        logger.warn "\'$testdataDirKey\' property not defined."
        return false
    } else {
        testdataDirVal = property(testdataDirKey) as String;

        if (!new File(testdataDirVal).isDirectory()) {
            logger.warn "\'$testdataDirVal\' directory not found."
            return false
        } else {
            return true
        }
    }
}

///////////////////////////////////////////////// Root /////////////////////////////////////////////////

task testAll(group: 'Build') {
    description = 'Runs all subproject Test tasks'
    dependsOn subprojects*.tasks*.withType(Test)
}

task rootTestReport(type: TestReport, group: 'Reports') {
    description = 'Generates an aggregate test report'
    destinationDir = file("$buildDir/reports/allTests")

    Collection<Task> subprojectTestTasks = subprojects*.tasks*.withType(Test).flatten()

    // All Test tasks will be finalized by this task. As a result, this task needn't be invoked directly.
    subprojectTestTasks*.finalizedBy it

    // We could also do "reportOn subprojectTestTasks" here, but that would cause this task to be dependent on all
    // subproject Tests. So, we couldn't do something like ":grib:test" and expect only GRIB tests to run because:
    //     ":grib:test" --finalizedBy--> ":rootTestReport" --dependsOn--> "all_subproject_Tests"
    // In other words, all subproject tests would get run, no matter what.
    // Passing File arguments to reportOn() instead doesn't create that dependency.
    reportOn subprojectTestTasks*.binResultsDir

    // Wait until all Test tasks have run. This creates a task *ordering*, not a dependency.
    mustRunAfter subprojectTestTasks
}

apply plugin: "base"  // Gives us the "clean" task for removing rootTestReport's output.
