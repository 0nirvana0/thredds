configure(javaProjects) {
    apply plugin: 'java'  // For testCompile configuration.
    apply from: "$rootDir/gradle/dependencies.gradle"

    dependencies {
        testCompile libraries["junit"]

        if (name != "cdm") {
            // Applying this to "cdm" creates a circular dependency.
            testCompile project(path: ':cdm', configuration: 'testArtifacts')
        }
    }

    Project subproject = delegate

    // Add an SLF4J binding to testRuntime, if necessary.
    afterEvaluate {
        if (testRuntimeHasDepNamed(subproject, "slf4j-api")) {
            if (!testRuntimeHasDepNamed(subproject, "slf4j-jdk14") &&
                    !testRuntimeHasDepNamed(subproject, "log4j-slf4j-impl")) {
                logger.info "Using default binding (slf4j-jdk14) to log testing messages in '$subproject.path'."
                dependencies.testRuntime libraries["slf4j-jdk14"]
            }
        }
    }
}

boolean testRuntimeHasDepNamed(Project project, String depName) {
    try {
        // Groovy truth: empty collections are coerced to false.
        project.configurations.getByName('testRuntime').allDependencies.findAll { it.name == depName }
    } catch (UnknownConfigurationException e) {  // Project did not have a configuration named 'testRuntime'.
        logger.debug e.message
        false
    }
}

// Process test exclusions.
gradle.taskGraph.whenReady { TaskExecutionGraph taskGraph ->
    Collection<Task> testTasks = taskGraph.allTasks.findAll { it instanceof Test }
    if (!testTasks) {
        return  // We're not running any tests.
    }

    // These appear to be the only environment variables that Jenkins defines: http://goo.gl/iCh08k
    // Is there a better way to detect Jenkins?
    boolean isJenkins = System.env['JENKINS_URL']  // We only care if prop is defined, not its actual value.

    boolean isTravis = System.env['TRAVIS']

    // We only want to write these log messages once, which is why we don't have them in the "testTasks*.configure{}"
    // block below.
    if (isTravis) {
        logger.warn "Skipping all NotTravis tests: detected that we're running in the Travis environment."
    }

    String contentRootKey = "tds.content.root.path"
    boolean isContentRootAvailable = isPropertyValidDirectory(contentRootKey)
    if (!isContentRootAvailable && !isJenkins) {        // Never skip any tests on Jenkins.
        logger.warn "Skipping all NeedsContentRoot tests."
    }

    String testdataDirKey = "unidata.testdata.path"
    boolean isCdmUnitTestDirAvailable = isPropertyValidDirectory(testdataDirKey)
    if (!isCdmUnitTestDirAvailable && !isJenkins) {     // Never skip any tests on Jenkins.
        logger.warn "Skipping all NeedsCdmUnitTest tests."
    }

    // FIXME: Should I be using org.gradle.api.DomainObjectCollection.all(Closure) here instead?
    testTasks*.configure {
        useJUnit {
            // Propagate to Gradle Test Executor.
            String jnaKey = 'jna.library.path'
            String jnaVal = System.getProperty(jnaKey)
            if (jnaVal) {
                systemProperty jnaKey, jnaVal
            }

            if (isTravis) {
                ignoreFailures false  // On Travis, abort the build if any tests fail.

                // Temporarily commented out to test JUnit Assume for server reachability.
                // excludeCategories 'ucar.unidata.test.util.NotTravis'
            } else {
                ignoreFailures true  // In every other environment, don't let test failures abort the build.
            }

            systemProperty contentRootKey, rootProject.property(contentRootKey)  // Propagate to Gradle Test Executor.

            if (!isContentRootAvailable && !isJenkins) {        // Never skip any tests on Jenkins.
                excludeCategories 'ucar.unidata.test.util.NeedsContentRoot'

                if (path == ":it:integrationTest") {
                    logger.warn "Skipping all integration tests (task \'$path\'): " +
                            "\'$contentRootKey\' property not defined."

                    // We can't stand up a functioning TDS test instance without a valid content root,
                    // so disable the integration test task altogether.
                    setEnabled false
                }
            }

            systemProperty testdataDirKey, rootProject.property(testdataDirKey)  // Propagate to Gradle Test Executor.

            if (!isCdmUnitTestDirAvailable && !isJenkins) {     // Never skip any tests on Jenkins.
                excludeCategories 'ucar.unidata.test.util.NeedsCdmUnitTest'
            }
        }
    }

    // Add the content root and testdata dir to :it's gretty extension as system properties.
    // This is how we propagate these properties to the embedded Tomcat that's started for :it:integrationTest.
    project(":it").gretty.systemProperty contentRootKey, rootProject.property(contentRootKey)
    project(':it').gretty.systemProperty testdataDirKey, rootProject.property(testdataDirKey)
}

import java.nio.file.*

/**
 * Returns {@code true} if the given Project property exists and denotes an existing directory in the file system.
 * Otherwise, {@code false} is returned and the property is set to {@code "/NO/$propKey/FOUND/"}.
 *
 * @param propKey   the name of a property set in this Project. It'll likely have been loaded from gradle.properties.
 * @return {@code true} if the given Project property exists and denotes an existing directory in the file system.
 */
boolean isPropertyValidDirectory(String propKey) {
    def defaultPropVal = Paths.get(buildDir.path, "NO/$propKey/FOUND/").toAbsolutePath()

    if (!hasProperty(propKey)) {
        logger.warn "\"$propKey\" property not defined."
        ext[propKey] = defaultPropVal            // New property must be created in the ext namespace.
        return false
    } else {
        String propVal = property(propKey) as String;
        Path dirPath = Paths.get propVal

        if (!dirPath.isAbsolute()) {
            logger.warn "$propKey=\"$propVal\"; value is not an absolute path in this file system."
        } else if (Files.notExists(dirPath)) {
            logger.warn "$propKey=\"$propVal\"; value is not an existing file."
        } else if (!Files.isDirectory(dirPath)) {
            logger.warn "$propKey=\"$propVal\"; value is not a directory."
        } else {
            return true
        }

        logger.info "Setting default property value: $propKey=\"$defaultPropVal\""
        setProperty propKey, defaultPropVal  // Property exists on Project; change its value.
        return false
    }
}

///////////////////////////////////////////////// Root /////////////////////////////////////////////////

task testAll(group: 'Build') {
    description = 'Runs all subproject Test tasks'
    dependsOn subprojects*.tasks*.withType(Test)
}

task rootTestReport(type: TestReport, group: 'Reports') {
    description = 'Generates an aggregate test report'
    destinationDir = file("$buildDir/reports/allTests")

    Collection<Task> subprojectTestTasks = subprojects*.tasks*.withType(Test).flatten()

    // All Test tasks will be finalized by this task. As a result, this task needn't be invoked directly.
    subprojectTestTasks*.finalizedBy it

    // We could also do "reportOn subprojectTestTasks" here, but that would cause this task to be dependent on all
    // subproject Tests. So, we couldn't do something like ":grib:test" and expect only GRIB tests to run because:
    //     ":grib:test" --finalizedBy--> ":rootTestReport" --dependsOn--> "all_subproject_Tests"
    // In other words, all subproject tests would get run, no matter what.
    // Passing File arguments to reportOn() instead doesn't create that dependency.
    reportOn subprojectTestTasks*.binResultsDir

    // Wait until all Test tasks have run. This creates a task *ordering*, not a dependency.
    mustRunAfter subprojectTestTasks
}

apply plugin: "base"  // Gives us the "clean" task for removing rootTestReport's output.
