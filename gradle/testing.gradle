ext {
    // These appear to be the only environment variables that Jenkins defines: http://goo.gl/iCh08k
    // Is there a better way to detect Jenkins?
    jenkinsEnvVar = 'JENKINS_URL'
    isJenkins = System.env['JENKINS_URL'] as boolean  // We only care if prop is defined, not its actual value.

    if (isJenkins) {
        logger.warn "Skipping all NotJenkins tests: detected that we're running in the Jenkins environment."
    }


    travisEnvVar = 'TRAVIS'
    isTravis = System.env['TRAVIS'] as boolean        // We only care if prop is defined, not its actual value.

    if (isTravis) {
        logger.warn "Skipping all NotTravis tests: detected that we're running in the Travis environment."
    }


    contentRootKey = 'tds.content.root.path'
    isContentRootAvailable = isPropertyValidDirectory(contentRootKey)

    if (!isContentRootAvailable && !isJenkins) {        // Don't skip tests on Jenkins, except NotJenkins ones.
        logger.warn "Skipping all NeedsContentRoot tests."
    }


    testdataDirKey = 'unidata.testdata.path'
    isCdmUnitTestDirAvailable = isPropertyValidDirectory(testdataDirKey)

    if (!isCdmUnitTestDirAvailable && !isJenkins) {     // Don't skip tests on Jenkins, except NotJenkins ones.
        logger.warn "Skipping all NeedsCdmUnitTest tests."
    }


    timesPrinted = 0
}

/**
 * Returns {@code true} if the given system property is defined and denotes an existing directory. Otherwise,
 * {@code false} is returned and the property is set to {@code "$buildDir/NO/$sysPropKey/FOUND/"}.
 *
 * @param sysPropKey  the name of a system property. It'll likely have been set either on the command line or in
 *                    gradle.properties.
 * @return  {@code true} if the given system property is defined and denotes an existing directory.
 */
boolean isSystemPropertyAValidDirectory(String sysPropKey) {
    String sysPropVal = System.properties[sysPropKey]

    if (sysPropVal) {
        if (Files.isDirectory(Paths.get(sysPropVal))) {
            return true
        } else {
            logger.warn "-D$sysPropKey=\"$sysPropVal\"; value is not a directory."
        }
    } else {
        logger.warn "\"$sysPropKey\" system property not defined."
    }

    // Initialization for our tests requires that we define SOME value for 'tds.content.root.path' and
    // 'unidata.testdata.path'. To clearly indicate that the property wasn't set properly by the user, we're going to
    // create a path containing the segment "NO/$sysPropKey/FOUND".
    //
    // However, we must exercise some care in our choice of parent directory for that segment. This is because when we
    // start the embedded TDS server for :it:integrationTest, log4j will attempt to create the directory
    // "${sys:tds.content.root.path}/thredds/logs" (see TDS's log4j.xml). In the event that the user fails to define
    // that property, the responsible place to create this log directory is under the project build directory.
    String defaultSysPropVal = Paths.get(buildDir.path, "NO", sysPropKey, "FOUND").toAbsolutePath().toString()

    logger.info "Setting default property value: -D$propKey=\"$defaultPropVal\""
    System.properties[sysPropKey] = defaultSysPropVal
    return false
}

/**
 * Returns {@code true} if the given Project property exists and denotes an existing directory in the file system.
 * Otherwise, {@code false} is returned and the property is set to {@code "/NO/$propKey/FOUND/"}.
 *
 * @param propKey the name of a property set in this Project. It'll likely have been loaded from gradle.properties.
 * @return {@code true} if the given Project property exists and denotes an existing directory in the file system.
 */
boolean isPropertyValidDirectory(String propKey) {
    def defaultPropVal = Paths.get(buildDir.path, "NO", propKey, "FOUND").toAbsolutePath().toString()

    if (!hasProperty(propKey)) {
        logger.warn "\"$propKey\" property not defined."
        rootProject.ext[propKey] = defaultPropVal            // New property must be created in the ext namespace.
        return false
    } else {
        String propVal = rootProject.property(propKey) as String;
        Path dirPath = Paths.get propVal

        if (!dirPath.isAbsolute()) {
            logger.warn "$propKey=\"$propVal\"; value is not an absolute path in this file system."
        } else if (Files.notExists(dirPath)) {
            logger.warn "$propKey=\"$propVal\"; value is not an existing file."
        } else if (!Files.isDirectory(dirPath)) {
            logger.warn "$propKey=\"$propVal\"; value is not a directory."
        } else {
            return true
        }

        logger.info "Setting default property value: $propKey=\"$defaultPropVal\""
        rootProject.setProperty propKey, defaultPropVal  // Property exists on Project; change its value.
        return false
    }
}

///**
// * Returns {@code true} if the given Project property exists and denotes an existing directory in the file system.
// * Otherwise, {@code false} is returned and the property is set to {@code "/NO/$propKey/FOUND/"}.
// *
// * @param propKey the name of a property set in this Project. It'll likely have been loaded from gradle.properties.
// * @return {@code true} if the given Project property exists and denotes an existing directory in the file system.
// */
//boolean isPropertyValidDirectory(String propKey) {
//    if (!hasProperty(propKey)) {
//        logger.warn "\'$propKey\' property not defined."
//        ext[propKey] = "/NO/$propKey/FOUND/"            // New property must be created in the ext namespace.
//        return false
//    } else {
//        String propVal = property(propKey) as String;
//
//        if (!new File(propVal).isDirectory()) {
//            logger.warn "\'$propVal\' directory not found."
//            setProperty propKey, "/NO/$propKey/FOUND/"  // Property exists on Project; change its value.
//            return false
//        } else {
//            return true
//        }
//    }
//}


configure(javaProjects) {
    apply plugin: 'java'  // For testCompile configuration.
    apply from: "$rootDir/gradle/dependencies.gradle"

test {
    systemProperties['testargs'] =
            System.getProperty("testargs", "")
}
    dependencies {
        testCompile libraries["junit"]

        if (name != "cdm") {
            // Applying this to "cdm" creates a circular dependency.
            testCompile project(path: ':cdm', configuration: 'testArtifacts')
        }
    }


    tasks.withType(Test).all {
        if (timesPrinted == 0) {
            println "===System Properties ($path)==="
            System.properties.each { key, value ->
                println "\t$key = $value"
            }

            timesPrinted++
        }

        // Propagates all system properties set on the Gradle process to the test executors.
        systemProperties System.properties
    }


    Project subproject = delegate as Project

    // Add an SLF4J binding to testRuntime, if necessary.
    afterEvaluate {
        if (testRuntimeHasDepNamed(subproject, "slf4j-api")) {
            if (!testRuntimeHasDepNamed(subproject, "slf4j-jdk14") &&
                    !testRuntimeHasDepNamed(subproject, "log4j-slf4j-impl")) {
                logger.info "Using default binding (slf4j-jdk14) to log testing messages in '$subproject.path'."
                dependencies.testRuntime libraries["slf4j-jdk14"]
            }
        }
    }
}

boolean testRuntimeHasDepNamed(Project project, String depName) {
    try {
        // Groovy truth: empty collections are coerced to false.
        project.configurations.getByName('testRuntime').allDependencies.findAll { it.name == depName }
    } catch (UnknownConfigurationException e) {  // Project did not have a configuration named 'testRuntime'.
        logger.debug e.message
        false
    }
}

// Process test exclusions.
gradle.taskGraph.whenReady { TaskExecutionGraph taskGraph ->
    Collection<Task> testTasks = taskGraph.allTasks.findAll { it instanceof Test }
    if (!testTasks) {
        return  // We're not running any tests.
    }

    println "===System Properties==="
    System.properties.each { key, value ->
        println "\t$key = $value"
    }

    // These appear to be the only environment variables that Jenkins defines: http://goo.gl/iCh08k
    // Is there a better way to detect Jenkins?
    boolean isJenkins = System.env['JENKINS_URL']  // We only care if prop is defined, not its actual value.

    boolean isTravis = System.env['TRAVIS']

    // We only want to write these log messages once, which is why we don't have them in the "testTasks*.configure{}"
    // block below.
    if (isJenkins) {
        logger.warn "Skipping all NotJenkins tests: detected that we're running in the Jenkins environment."
    }

    if (isTravis) {
        logger.warn "Skipping all NotTravis tests: detected that we're running in the Travis environment."
    }

    String contentRootKey = "tds.content.root.path"
    boolean isContentRootAvailable = isPropertyValidDirectory(contentRootKey)
    if (!isContentRootAvailable && !isJenkins) {        // Don't skip tests on Jenkins, except NotJenkins ones.
        logger.warn "Skipping all NeedsContentRoot tests."
    }

    String testdataDirKey = "unidata.testdata.path"
    boolean isCdmUnitTestDirAvailable = isPropertyValidDirectory(testdataDirKey)
    if (!isCdmUnitTestDirAvailable && !isJenkins) {     // Don't skip tests on Jenkins, except NotJenkins ones.
        logger.warn "Skipping all NeedsCdmUnitTest tests."
    }

    // FIXME: Should I be using org.gradle.api.DomainObjectCollection.all(Closure) here instead?
    testTasks*.configure {
        useJUnit {
            // Propagate to Gradle Test Executor.
            String jnaKey = 'jna.library.path'
            String jnaVal = System.getProperty(jnaKey)
            if (jnaVal) {
                systemProperty jnaKey, jnaVal
            }

            if (isJenkins) {
                excludeCategories 'ucar.unidata.test.util.NotJenkins'
            }

            if (isTravis) {
                ignoreFailures false  // On Travis, abort the build if any tests fail.
            } else {
                ignoreFailures true  // In every other environment, don't let test failures abort the build.
            }

            systemProperty contentRootKey, rootProject.property(contentRootKey)  // Propagate to Gradle Test Executor.

            if (!isContentRootAvailable && !isJenkins) {        // Don't skip tests on Jenkins, except NotJenkins ones.
                excludeCategories 'ucar.unidata.test.util.NeedsContentRoot'

                if (path == ":it:integrationTest") {
                    logger.warn "Skipping all integration tests (task \'$path\'): " +
                            "\'$contentRootKey\' property not defined."

                    // We can't stand up a functioning TDS test instance without a valid content root,
                    // so disable the integration test task altogether.
                    enabled = false
                }
            }

            systemProperty testdataDirKey, rootProject.property(testdataDirKey)  // Propagate to Gradle Test Executor.

            if (!isCdmUnitTestDirAvailable && !isJenkins) {     // Don't skip tests on Jenkins, except NotJenkins ones.
                excludeCategories 'ucar.unidata.test.util.NeedsCdmUnitTest'
            }
        }
    }

    // Add the content root and testdata dir to :it's gretty extension as system properties.
    // This is how we propagate these properties to the embedded Tomcat that's started for :it:integrationTest.
    project(":it").gretty.systemProperty contentRootKey, rootProject.property(contentRootKey)
    project(':it').gretty.systemProperty testdataDirKey, rootProject.property(testdataDirKey)
}

///////////////////////////////////////////////// Root /////////////////////////////////////////////////

task testAll(group: 'Build') {
    description = 'Runs all subproject Test tasks'
    dependsOn subprojects*.tasks*.withType(Test)
}

task rootTestReport(type: TestReport, group: 'Reports') {
    description = 'Generates an aggregate test report'
    destinationDir = file("$buildDir/reports/allTests")

    Collection<Task> subprojectTestTasks = subprojects*.tasks*.withType(Test).flatten()

    // All Test tasks will be finalized by this task. As a result, this task needn't be invoked directly.
    subprojectTestTasks*.finalizedBy it

    // We could also do "reportOn subprojectTestTasks" here, but that would cause this task to be dependent on all
    // subproject Tests. So, we couldn't do something like ":grib:test" and expect only GRIB tests to run because:
    //     ":grib:test" --finalizedBy--> ":rootTestReport" --dependsOn--> "all_subproject_Tests"
    // In other words, all subproject tests would get run, no matter what.
    // Passing File arguments to reportOn() instead doesn't create that dependency.
    reportOn subprojectTestTasks*.binResultsDir

    // Wait until all Test tasks have run. This creates a task *ordering*, not a dependency.
    mustRunAfter subprojectTestTasks
}

apply plugin: "base"  // Gives us the "clean" task for removing rootTestReport's output.
