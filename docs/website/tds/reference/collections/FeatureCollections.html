<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.2">
<title>Configuring TDS with the featureCollection element</title>
<link rel="stylesheet" href="./../../cdm.css">
</head>
<body class="article">
<div id="header">
<h1>Configuring TDS with the featureCollection element</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_overview">Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <strong>featureCollection</strong> element is a way to tell the TDS to serve collections of <a href="../../../netcdf-java/reference/FeatureDatasets/Overview.html">CDM
Feature Datasets</a>. Currently this is used for gridded and point datasets whose time and spatial coordinates are recognized by the CDM software stack.
This allows the TDS to automatically create logical datasets composed of collections of files, and to allow subsetting in coordinate space on them, eg
through the WMS, WCS, and Netcdf Subsetting Service.</p>
</div>
<div class="paragraph">
<p>Feature Collections have been undergoing continual development and refinement in the recent version of the TDS, and as you upgrade there are (mostly)
minor changes to configuration and usage. The <strong>featureCollection</strong> element was first introduced TDS 4.2, replacing the <strong>fmrcDataset</strong> element in earlier
versions. TDS 4.2 allowed featureType = <em>FMRC, Point,</em> and <em>Station</em>. TDS 4.3 added featureType = <em>GRIB</em>, used for collections of GRIB files. TDS
4.5 changed this usage to featureType = <em>GRIB1 or GRIB2</em>. <strong>Currently, one should only serve GRIB files with featureCollection=GRIB1 or GRIB2. One
should not use FMRC, or NcML Aggregations on GRIB files.</strong></p>
</div>
<div class="paragraph">
<p>A fair amount of the complexity of feature collections is managing the collection of files on the server, both in creating indexes for performance,
and in managing collections that change. For high-performance servers, it is necessary to let a background process manage indexing, and the THREDDS
Data Manager (<a href="TDM.html">TDM</a>) is now available for that purpose.</p>
</div>
<div class="sect2">
<h3 id="_contents">Contents:</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#example">Example catalog elements</a></p>
</li>
<li>
<p><a href="#elements">Description of elements in TDS Configuration catalogs</a></p>
</li>
<li>
<p><a href="#changing">Static vs changing datasets</a></p>
</li>
<li>
<p><a href="#ncml">NcML Modifications</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This document gives an overview of Feature Collections, as well as a complete syntax of allowed elements. For Feature Type specific information, see:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="FmrcCollection.html">FMRC Collections</a><a href="http://www.unidata.ucar.edu/staff/caron/presentations/FmrcPoster.pdf" class="bare">http://www.unidata.ucar.edu/staff/caron/presentations/FmrcPoster.pdf</a></p>
</li>
<li>
<p><a href="PointFeatures.html">Point Collections</a></p>
</li>
<li>
<p><a href="GribCollections.html">GRIB Collections</a></p>
</li>
<li>
<p><a href="GribConfig.html">GRIB specific configuration</a></p>
</li>
<li>
<p><a href="GribCollectionFaq.html">GRIB Collection FAQs</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Also see:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="TDM.html">THREDDS Data Manager</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_example_catalog_elements">Example catalog elements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <strong>featureCollection</strong> element is a subtype of <strong>dataset</strong> element. It defines a <em>logical dataset</em> for the TDS. All of the elements that can be used
inside of a <strong>dataset</strong> element can be used inside of a <strong>featureCollection</strong> element.</p>
</div>
<div class="sect2">
<h3 id="_example_1_simple_case_using_defaults">Example 1: Simple case using defaults:</h3>
<div class="literalblock">
<div class="content">
<pre>1) &lt;featureCollection name="NCEP Polar Sterographic" featureType="GRIB2" path="grib/NCEP/NAM/Polar_90km"&gt;
2)   &lt;collection name="NCEP-NAM-Polar_90km" spec="/data/ldm/pub/native/grid/NCEP/NAM/Polar_90km/NAM_Polar_90km_.*\.grib2$"/&gt;
   &lt;/featureCollection&gt;</pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A GRIB2 Feature Collection dataset is defined, with the "human readable" name of "NCEP Polar Sterographic". Its URL path(s) will look like
<em><a href="http://server/thredds/&lt;service&gt;/grib/NCEP/NAM/Polar_90km/&#8230;&#8203" class="bare">http://server/thredds/&lt;service&gt;/grib/NCEP/NAM/Polar_90km/&#8230;&#8203</a>;</em> The Dataset ID is automatically set to the path, so that its dataset page will be
<em><a href="http://server/thredds/catalog/grib/NCEP/NAM/Polar_90km/catalog.xml?dataset=grib/NCEP/NAM/Polar_90km" class="bare">http://server/thredds/catalog/grib/NCEP/NAM/Polar_90km/catalog.xml?dataset=grib/NCEP/NAM/Polar_90km</a></em>/&#8230;&#8203;</p>
</li>
<li>
<p>Defines the files in the collection as any files in the directory <em>/data/ldm/pub/native/grid/NCEP/NAM/Polar_90km/</em> which match the regular
expression <em>"NAM_Polar_90km_.*\.grib2$</em>" . In this case, it means any filename starting with <em>"NAM_Polar_90km</em>"_ and ending with "<em>.grib2</em>". The
collection name is "NCEP-NAM-Polar_90km", which is used for index file names etc.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_example_2_more_fully_specify_the_options_explicitly">Example 2: More fully specify the options explicitly:</h3>
<div class="literalblock">
<div class="content">
<pre>&lt;featureCollection name="NCEP NAM Alaska(11km)" featureType="GRIB2" path="grib/NCEP/NAM/Alaska_11km"&gt;
  &lt;metadata inherited="true"&gt;
1)  &lt;serviceName&gt;GribServices&lt;/serviceName&gt;
2)  &lt;documentation type="summary"&gt;NCEP GFS Model : AWIPS 230 grid&lt;/documentation&gt;
  &lt;/metadata&gt;
3)&lt;collection spec="/data/ldm/pub/native/grid/NCEP/NAM/Alaska_11km/.*grib2$"
              name="NAM_Alaska_11km"
4)            dateFormatMark="#NAM_Alaska_11km_#yyyyMMdd_HHmm"
5)            timePartition="file"
6)            olderThan="5 min"/&gt;
7)&lt;update startup="nocheck" trigger="allow"/&gt;
8)&lt;tdm rewrite="test" rescan="0 0/15 * * * ? *" /&gt;
9)&lt;gribConfig datasetTypes="TwoD Best Latest" /&gt;
&lt;/featureCollection&gt;</pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Arbitrary metadata can be added to the catalog. Here, we indicate to use the service called "GribServices" (not shown, but likely a compound
service that includes all the services you want to provide for GRIB Feature Collections).</p>
</li>
<li>
<p>A documention element of type "<em>summary</em>" is added to the catalog for this dataset.</p>
</li>
<li>
<p>The collection consists of all files ending with "<em>grib2</em>" in the directory "<em>/data/ldm/pub/native/grid/NCEP/NAM/Alaska_11km/</em>".</p>
</li>
<li>
<p>A date will be extracted from the filename, and the files will then be sorted by date. Important if the lexigraphic ordering is different that the
date order.</p>
</li>
<li>
<p>Partitioning will happen at the file level.</p>
</li>
<li>
<p>Only include files whose lastModified date is more than 5 minutes old. This is to exclude files that are actively being created.</p>
</li>
<li>
<p>Instruct the TDS to use the collection index if it already exists, without testing if its up-to-date, and also to allow external triggers.</p>
</li>
<li>
<p>Instruct the TDM to examine all the files to detect if they have changed since the index was written. Rescan every 15 minutes.</p>
</li>
<li>
<p>(GRIB specific) Show the <em>TwoD</em> and <em>Best</em> datasets, as well as a link to the <em>latest</em> partition.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_description_of_elements_in_tds_configuration_catalogs">Description of elements in TDS Configuration catalogs</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_featurecollection_element">featureCollection element</h3>
<div class="paragraph">
<p>A <strong>featureCollection</strong> is a kind of <strong>dataset</strong> element, and so can contain the same elements and attributes of that element. Following is the XML Schema
definition for the <em>featureCollection</em> element:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;xsd:element name="featureCollection" substitutionGroup="dataset"&gt;
  &lt;xsd:complexType&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="DatasetType"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element type="collectionType" name="collection"/&gt;
          &lt;xsd:element type="updateType" name="update" minOccurs="0"/&gt;
          &lt;xsd:element type="tdmType" name="tdm" minOccurs="0"/&gt;
          &lt;xsd:element type="protoDatasetType" name="protoDataset" minOccurs="0"/&gt;
          &lt;xsd:element type="fmrcConfigType" name="fmrcConfig" minOccurs="0"/&gt;
          &lt;xsd:element type="pointConfigType" name="pointConfig" minOccurs="0"/&gt;
          &lt;xsd:element type="gribConfigType" name="gribConfig" minOccurs="0"/&gt;
           &lt;xsd:element type="fileSortType" name="filesSort" minOccurs="0" /&gt;
          &lt;xsd:element ref="ncml:netcdf" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
        &lt;xsd:attribute name="featureType" type="featureTypeChoice" use="required"/&gt;
        &lt;xsd:attribute name="path" type="xsd:string" use="required"/&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:element&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Here is an example <strong>featureCollection</strong> as you might put it into a TDS catalog:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>1)&lt;featureCollection name="Metar Station Data" harvest="true" featureType="Station" path="nws/metar/ncdecoded"&gt;
2) &lt;metadata inherited="true"&gt;
    &lt;serviceName&gt;fullServices&lt;/serviceName&gt;
    &lt;documentation type="summary"&gt;Metars: hourly surface weather observations&lt;/documentation&gt;
    &lt;documentation xlink:href="http://metar.noaa.gov/" xlink:title="NWS/NOAA information"/&gt;
    &lt;keyword&gt;metar&lt;/keyword&gt;
    &lt;keyword&gt;surface observations&lt;/keyword&gt;
   &lt;/metadata&gt;
3) &lt;collection name="metars" spec="/data/ldm/pub/decoded/netcdf/surface/metar/Surface_METAR_#yyyyMMdd_HHmm#.nc$" /&gt;
4) &lt;update startup="test" rescan="0 0/15 * * * ? *"/&gt;
5) &lt;protoDataset choice="Penultimate" /&gt;
6) &lt;pointConfig datasetTypes="cdmrFeature Files"/&gt;
7) &lt;netcdf xmlns="http://www.unidata.ucar.edu/namespaces/netcdf/ncml-2.2"&gt;
     &lt;attribute name="Conventions" value="CF-1.6"/&gt;
   &lt;/netcdf&gt;
&lt;/featureCollection&gt;</pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A <strong>featureCollection</strong> is declared, using the <em>name</em> and <em>harvest</em> attributes declared by the dataset element. The <strong><em>featureType</em></strong> is a mandatory
attribute defining the type of the feature collection. The <em>*path*</em> is also required, which defines what the URL of this collection will be. It must
be unique over the entire TDS. If an <em>ID</em> attribute is not specified on the featureCollection, the path attribute is used as the ID (this is a
recommended idiom).</p>
</li>
<li>
<p>As is usual with dataset elements, a block of metadata can be declared that will be inherited by all the datasets.</p>
</li>
<li>
<p>The collection of files is defined. Each dataset is assigned a nominal time by extracting a date from the filename.</p>
</li>
<li>
<p>Specify that the collection is updated, when the TDS starts and in a background thread, every 15 minutes.</p>
</li>
<li>
<p>The prototype dataset is the next-to-last in the collection when sorted by time.</p>
</li>
<li>
<p>Configuration specific to the Point feature type: expose a <em>cdmrRemote</em> service on the entire collection, and also serve all the component files
using the default service, in this example the compound service <em>fullServices</em>.</p>
</li>
<li>
<p>This NcML wraps each dataset in the collection. This attribute overrides any existing one in the datasets; it tells the CDM to parse the station
information using the CF Conventions.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_collection_element">collection element</h3>
<div class="paragraph">
<p>A <strong>collection</strong> element defines the collection of datasets. Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;collection spec="/data/ldm/pub/native/satellite/3.9/WEST-CONUS_4km/WEST-CONUS_4km_3.9_.*gini$"
           dateFormatMark="#WEST-CONUS_4km_3.9_#yyyyMMdd_HHmm"
           name="WEST-CONUS_4km" olderThan="15 min" /&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The XML Schema for the <em>collection</em> element:</p>
</div>
<div class="literalblock">
<div class="content">
<pre> &lt;xsd:complexType name="collectionType"&gt;
1)  &lt;xsd:attribute name="spec" type="xsd:string" use="required"/&gt;
2)  &lt;xsd:attribute name="name" type="xsd:token"/&gt;
3)  &lt;xsd:attribute name="olderThan" type="xsd:string" /&gt;
4)  &lt;xsd:attribute name="dateFormatMark" type="xsd:string"/&gt;
5)  &lt;xsd:attribute name="timePartition" type="xsd:string"/&gt;
 &lt;/xsd:complexType&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>where</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>spec</strong> (required): <a href="CollectionSpecification.html">collection specification</a> string. In this example, the collection contains all files in the
directory <em>/data/ldm/pub/native/satellite/3.9/WEST-CONUS_4km/</em> whose filename matches the regular expression <em>"WEST-CONUS_4km_3.9</em>.<strong>gini$"_ (where
<em>".</strong>"</em> means "match any number of characters" and <em>"gini$"</em> means "ends with the characters <strong>gini"</strong>. If you wanted to match <strong>".gini"</strong>, you would
need to escape the ".", ie <em>"\.gini$"</em>).</p>
</li>
<li>
<p><strong>name</strong> (required): the collection name, which <em>*must be unique for all collections served by your TDS*</em>. This is used for external triggers, for
the CDM collection index files, and for logging and debugging messages. If missing, the <em>name</em> attribute on the <em>&lt;featureCollection&gt;</em> element is used.
However, we recommend that you create a unique, immutable name for the dataset collection, and put it in this <strong>name</strong> attribute of the <strong>collection</strong>
element.</p>
</li>
<li>
<p><strong>olderThan</strong> (optional): Only files whose lastModified date is older than this are included. This is used to exclude files that are in the process
of being written. However, it only applies to newly found files; that is, once a file is in the collection it is not removed because it was updated.</p>
</li>
<li>
<p><strong>dateFormatMark</strong> (optional): This defines a <em><a href="#dateExtractor">DateExtractor</a></em>, which is applied to each file in the collection to assign it a
date, which is used for sorting, getting the latest file, and possibly for time partitioning. In this example, the string <strong>WEST-CONUS_4km_3.9_</strong> is
located in each file path, then the <a href="SimpleDateFormat.html">SimpleDateFormat</a> template <strong>yyyyMMdd_HHmm</strong> is applied to the next characters of the
filename to create a date. A DateExtractor can also be defined in the <a href="CollectionSpecification.html">collection specification</a> string, but in that
case the date must be contained just in the file name, as opposed to the complete file path which includes all of the parent directory names. <em>Use
this OR a date extractor in the specification string, but not both.</em></p>
</li>
<li>
<p><strong>timePartition</strong> (optional): Currently only used by GRIB collections, see <a href="Partitions.html">here</a> for more info.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_date_extractor">Date Extractor</h3>
<div class="paragraph">
<p>Feature Collections sometimes (Point, FMRC (ususally), and time partitioned GRIB) need to know how to sort the collection of files, and in those cases
you need to have a date in the filename, and to specify a date extractor in the specification string or include a dateFormatMark attribute.</p>
</div>
<div class="paragraph">
<p>If the date is in the filename only, you can use the <a href="CollectionSpecification.html">collection specification</a> string, aka a <strong><em>spec</em></strong>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/data/ldm/pub/native/grid/NCEP/GFS/Alaska_191km/GFS_Alaska_191km_#yyyyMMdd_HHmm#\.nc$</pre>
</div>
</div>
<div class="paragraph">
<p>applied to the file <em>/data/ldm/pub/native/grid/NCEP/GFS/Alaska_191km/GFS_Alaska_191km_20111226_1200.grib1</em> this would extract the date <em>2011-11-26T12:00:00.</em></p>
</div>
<div class="paragraph">
<p>In this case, <em><mark>yyyyMMdd_HHmm</mark></em> is <strong>positional</strong>: it counts the charactors before the '#' and then extracts the charactors in the filename (here at
position 17 though 30) and applies the <a href="SimpleDateFormat.html">SimpleDateFormat</a> <em>yyyyMMdd_HHmm</em> pattern to them.</p>
</div>
<div class="paragraph">
<p>When the date is in the directory name and not completely in the filename, you must use the <strong>dateFormatMark</strong>. For example with a file path</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/data/ldm/pub/native/grid/NCEP/GFS/Alaska_191km/20111226/Run_1200.grib1</pre>
</div>
</div>
<div class="paragraph">
<p>use</p>
</div>
<div class="literalblock">
<div class="content">
<pre>dateFormatMark="#Alaska_191km/#yyyyMMdd'/Run_'HHmm"</pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the <em>'#'</em> characters delineate the <strong>substring match</strong> on the entire pathname. Immediately following the match comes the string to be
given to <a href="SimpleDateFormat.html">SimpleDateFormat</a>, in this example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>yyyyMMdd'/Run_'HHmm</pre>
</div>
</div>
<div class="paragraph">
<p>Note that the <em>/Run_</em> is enclosed in single quotes. This tells SimpleDateFormat to interpret these characters literally, and they must match
characters in the filename exactly.</p>
</div>
<div class="paragraph">
<p>You might also need to put the SimpleDateFormat before the substring match, eg in the following, <em>stuff</em> differs for each subdirectory, so you can&#8217;t
match on it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/dataroot/stuff/20111226/Experiment-02387347.grib1</pre>
</div>
</div>
<div class="paragraph">
<p>However, you can match on <em>Experiment</em> so you can use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>dateFormatMark="yyyyMMdd#/Experiment#"</pre>
</div>
</div>
<div class="paragraph">
<p>Note that whatever you match on must be unique in the pathname.</p>
</div>
</div>
<div class="sect2">
<h3 id="_protodataset_element_not_used_by_grib">protoDataset element (Not used by GRIB).</h3>
<div class="paragraph">
<p>Provides control over the choice of the <strong><em>prototype dataset</em></strong> for the collection. The prototype dataset is used to populate the metadata for the
feature collection. Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;protoDataset choice="Penultimate" change="0 2 3 * * ? *"&gt;
  &lt;netcdf xmlns="http://www.unidata.ucar.edu/namespaces/netcdf/ncml-2.2"&gt;
    &lt;attribute name="featureType" value="timeSeries"/&gt;
  &lt;/netcdf&gt;
&lt;/protoDataset&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The XML Schema definition for the <em>protoDataset</em> element:</p>
</div>
<div class="literalblock">
<div class="content">
<pre> &lt;xsd:complexType name="protoDatasetType"&gt;
   &lt;xsd:sequence&gt;
1)   &lt;xsd:element ref="ncml:netcdf" minOccurs="0"/&gt;
   &lt;/xsd:sequence&gt;
2) &lt;xsd:attribute name="choice" type="protoChoices"/&gt;
3) &lt;xsd:attribute name="change" type="xsd:string"/&gt;
 &lt;/xsd:complexType&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>ncml:netcdf</strong> = (optional) ncml elements that modify the prototype dataset</p>
</li>
<li>
<p><strong>choice</strong>= [First | Random | Penultimate | Latest] : select prototype from a time ordered list, using the first, a randomly selected one, the
next to last, or the last dataset in the list. The default is "Penultimate".</p>
</li>
<li>
<p><strong>change</strong>= "cron expr" (optional). On rolling datsets, you need to change the prototype periodically, otherwise it will get deleted eventually.
This attribute specifies when the protoDataset should be reselected, using a <a href="http://www.quartz-scheduler.org/docs/tutorials/crontrigger.html">cron
expression</a>.</p>
<div class="ulist">
<ul>
<li>
<p><em>change = "0 2 3 * * ? *"</em> means every day at 3.02 am.</p>
</li>
<li>
<p>if not specified, the prototype dataset is not changed, except when restarting the TDS</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The choice of the protoDataset matters when the datasets are not <em>homogenous</em>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Global and variable attributes are taken from the prototype dataset.</p>
</li>
<li>
<p>If a variable appears in the prototype dataset, it will appear in the feature collection dataset. If it doesnt appear in other datasets, it will
have missing data for those times.</p>
</li>
<li>
<p>If a variable does not appears in the prototype dataset, it will not appear in the feature collection dataset, even if it appears in other
datasets.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_update_element">update element</h3>
<div class="paragraph">
<p>For collections that change, the <strong>update</strong> element provides options to update the collection, either synchronously (while a user request waits) or
asynchronously (in a background task, so that requests do not wait). If there is no update element, then the dataset is considered <em>static</em>, and the
indexes are never updated by the TDS. (To force updated indices, delete the collection index, usually <strong>&lt;collection root directory&gt; / &lt;dataset
name&gt;.ncx</strong>.). Examples:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;update startup="test" rescan="0 0/30 * * * ? *" trigger="false"/&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;update recheckAfter="15 min" /&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;update startup="never" trigger="allow" /&gt;</pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The first example says to test if the dataset has been updated when the TDS starts up, then test in a background process every 30 minutes. (Cannot
use for GRIB collections, see <em>tdm</em> element below). Do not allow external triggers.</p>
</li>
<li>
<p>The second example says to test if the dataset has been updated only when a request comes in for it, and the dataset hasn&#8217;t been checked for 15
minutes.</p>
</li>
<li>
<p>The third example tells the TDS to never update the collection indices, but to allow an external program (such as the TDM) to send a trigger
telling the TDS that it should reread the collection into memory. This is useful for large collections of data where even testing if a dataset has
changed can be costly.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The XML Schema definition for the <em>update</em> element:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;xsd:complexType name="updateType"&gt;
 1)  &lt;xsd:attribute name="startup" type="xsd:token"/&gt;
 2)  &lt;xsd:attribute name="recheckAfter" type="xsd:string" /&gt;
 3)  &lt;xsd:attribute name="rescan" type="xsd:token"/&gt;
 4)  &lt;xsd:attribute name="trigger" type="xsd:token"/&gt;
&lt;/xsd:complexType&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>startup</strong>: [<em>never</em> | <em>nocheck</em> | <em>testIndexOnly</em> | <em>test</em> | <em>always</em>] The collection may be read in on server startup, and tested whether
it is up to date.</p>
<div class="ulist">
<ul>
<li>
<p>If "<em>never</em>", the collection is used as it is. The collection index must already exist. Use this for very large collections that you dont want to
inadvertently scan.</p>
</li>
<li>
<p>If "<em>nocheck</em>", the collection index is used if it exists, without checking whether its up-to-date. If it doesnt exist, build it. <strong>This is the default in version 5.</strong></p>
</li>
<li>
<p>If "<em>testIndexOnly</em>", the collection index is used if it exists and it is newer than all of its immediate children. (<strong>experimental</strong>)</p>
</li>
<li>
<p>If "<em>test</em>" or "<em>true</em>", the collection is scanned and the new collection of children is compared to the old collection. If there are any
changes the index is rebuilt.</p>
</li>
<li>
<p>If "<em>always</em>", the collection is always rescanned and the indices are rebuilt.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>recheckAfter</strong>: This will cause a new scan whenever a request comes in and this much time has elapsed since the last scan. The request will wait
until the scan is finished and a new collection is built (if needed), and so is called <em>synchronous updating</em>. <em>*This option will be ignored if you
are using the rescan attribute or if you have a tdm element.*</em></p>
</li>
<li>
<p><strong>rescan</strong>: uses a <a href="http://www.quartz-scheduler.org/docs/tutorials/crontrigger.html">cron expression</a> to specify when the collection should be
rescanned in a background task, and testsed to see if it has changed. This is called <em>asynchronous updating</em>.</p>
</li>
<li>
<p><strong>trigger</strong>: if set to "allow" (default), then external triggering will be allowed. This allows collections to be updated by an external program
(or person using a browser) sending an explicit "trigger" URL to the server. This URL is protected by HTTPS, so you must <a href="#trigger">enable
triggers</a><a href="../RemoteManagement.html" class="bare">../RemoteManagement.html</a> for this to work. Set this to "false" to disable triggering.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For GRIB collections, dynamic updating of the collection by the TDS is no longer supported (use the TDM for this). Therefore <em>recheckAfter</em> and
<em>rescan</em> are ignored on an <em>update</em> element for a GRIB collection.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tdm_element_grib_only">tdm element (GRIB only)</h3>
<div class="paragraph">
<p>You must use the <strong>tdm</strong> element for GRIB collections that change. The <a href="TDM.html">TDM</a> is a separate process that uses the same configuration
catalogs as the TDS, and updates GRIB collections in the background. Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;tdm rewrite="test" rescan="0 4,19,34,49 * * * ? *"  /&gt;</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>This example tells the TDM (not the TDS) to test if the dataset has changed 4 times every hour, specifically, at 4,19,34, and 49 minutes past the
hour. If the collection has changed, new indices will be recreated, and a trigger will be sent to the TDS.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The XML Schema definition for the <em>tdm</em> element:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;xsd:complexType name="updateType"&gt;
 1)  &lt;xsd:attribute name="rewrite" type="xsd:token"/&gt;
 2)  &lt;xsd:attribute name="rescan" type="xsd:token"/&gt;
&lt;/xsd:complexType&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>rewrite</strong>: [<em>test</em> | <em>always</em>] If "<em>always</em>", the collection index is always rebuilt. If "<em>test</em>", the collection is scanned and a new
index is built if the collection has changed.</p>
</li>
<li>
<p><strong>rescan</strong>: uses a <a href="http://www.quartz-scheduler.org/docs/tutorials/crontrigger.html">cron expression</a> to specify when the collection should be
rescanned.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_enabling_triggers">Enabling Triggers</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>You must give the role "tdsTrigger" to any user who you want to have the right to send a trigger.</p>
</li>
<li>
<p>You can see a list of the Feature Collection datasets (and manually trigger a rescan) on the page
<strong><a href="https://server:port/thredds/admin/debug?Collections/showCollection" class="bare">https://server:port/thredds/admin/debug?Collections/showCollection</a></strong></p>
</li>
<li>
<p>The URL for the actual trigger is <a href="https://server:port/thredds/admin/collection/trigger?collection=" class="bare">https://server:port/thredds/admin/collection/trigger?collection=</a><em>name</em>, where <em>name</em> is the collection
name. This does a rescan, and updates if anything has changed.</p>
</li>
<li>
<p>The TDM uses the trigger <strong><a href="https://server:port/thredds/admin/collection/trigger?collection=" class="bare">https://server:port/thredds/admin/collection/trigger?collection=</a><em>name</em>&amp;nocheck</strong> . This does not rescan the
directory, it simply recreates the dataset using the current index.</p>
</li>
<li>
<p>Also see <a href="../RemoteManagement.html">enabling Remote Management</a></p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_file_sorting">File Sorting</h3>
<div class="paragraph">
<p>When a collection shows a list of files, the files will be sorted by increasing name. To use a decreasing sort, use the fileSort inside the
featureCollection element:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;featureCollection ... &gt;
  ...
  &lt;filesSort increasing = "false" /&gt;
&lt;/featureCollection&gt;</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_static_vs_changing_datasets">Static vs. changing datasets</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are several way to update a feature collection when it changes, specified by attributes on the <strong>update</strong> element:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>recheckAfter</strong> <strong> attribute</strong>:** causes a directory scan whenever a request comes in and the specified time has elapsed since the last scan. The
request waits until the scan is finished and a new collection is built. This is called <em>synchronous updating</em>.</p>
</li>
<li>
<p><strong>rescan</strong> and <strong>startup</strong> attributes: uses a background thread to keep the collection updated, so that requests never wait. This is called
<em>asynchronous updating</em>.</p>
</li>
<li>
<p><strong>trigger</strong> attribute: allows a trigger to be sent to the TDS to tell it to update the collection. This is called <em>user controlled updating</em>.</p>
</li>
<li>
<p><strong>tdm</strong> element: for GRIB collections, you may use the <a href="TDM.html">TDM</a> to do all index updating. This is called <em>external program updating</em>.</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_static_collection_small_or_rarely_used">Static Collection - Small or Rarely Used</h3>
<div class="paragraph">
<p>If you have a collection that doesn&#8217;t change, do not include an <strong>update</strong> element. The first time that the dataset is accessed, it will be read in and
then never changed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_static_collection_fast_response">Static Collection - Fast response</h3>
<div class="paragraph">
<p>If you have a collection that doesn&#8217;t change, but you want to have it ready for requests, then use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;update startup ="always" /&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The dataset will be scanned at startup time and then never changed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_large_static_collection">Large Static Collection</h3>
<div class="paragraph">
<p>You have a large collection, which takes a long time to scan. You must carefully control when/if it will be scanned.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;update startup ="nocheck" /&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The dataset will be read in at startup time by using the existing indexes (if they exist). If indexes dont exist, they will be created on startup.</p>
</div>
<div class="paragraph">
<p>If it occasionally changes, then you want to manually tell it when to rescan:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;update startup ="nocheck" trigger="allow" /&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The dataset will be read in at startup time by using the existing indexes, and you manually tell it when to rebuild the index. You must
<a href="#trigger">enable triggers</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_changing_collection_small_or_rarely_used">Changing Collection - Small or Rarely Used</h3>
<div class="paragraph">
<p>For collections that change but are rarely used, use the <strong>recheckAfter</strong> <strong> attribute on the <strong>update</strong> element</strong>.** This minimizes unneeded processing
for lightly used collections. This is also a reasonable strategy for small collections which don&#8217;t take very long to build.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;update recheckAfter="15 min" /&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Do not include both a <strong>recheckAfter</strong> and a <strong>rescan</strong> attribute. If you do, the <strong>recheckAfter</strong> will be ignored.</p>
</div>
</div>
<div class="sect2">
<h3 id="_changing_collection_fast_response">Changing Collection - Fast response</h3>
<div class="paragraph">
<p>When you want to ensure that requests are answered as quickly as possible, read it at startup and also update the collection in the background using
<strong>rescan</strong>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;update startup="test" rescan="0 20 * * * ? *" /&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>This <a href="http://www.quartz-scheduler.org/docs/tutorials/crontrigger.html">cron expressio</a>n says to rescan the collection files every hour at 20 past the
hour, and rebuild the dataset if needed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sporadically_changing_collection">Sporadically changing Collection</h3>
<div class="paragraph">
<p>To externally control when a collection is updated, use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;update trigger="allow" /&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>You must <a href="#trigger">enable remote triggers</a>, and when the dataset changes, send a message to a special URL in the TDS.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_grib_collections_only">GRIB Collections Only</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_changing_grib_collection">Changing GRIB Collection</h3>
<div class="paragraph">
<p>You have a GRIB collection that changes. The TDS can only scan/write indices at startup time. You must use the TDM to detect any changes.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;update startup="test" trigger="allow"/&gt;
&lt;tdm rewrite="test" rescan="0 0/15 * * * ? *" trigger="allow"/&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The dataset will be read in at startup time by the TDS using the existing indexes, and will be scanned by the <a href="TDM.html">TDM</a> every 15 minutes,
which will send a trigger as needed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_very_large_grib_collection_that_doesnt_change">Very Large GRIB Collection that doesnt change</h3>
<div class="paragraph">
<p>You have a very large collection, which takes a long time to scan. You must carefully control when/if it will be scanned.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;update startup="never"/&gt;
&lt;tdm rewrite="test"/&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The TDS never scans the collection, it always uses existing indices, which must already exist. Run the TDM first, then after the indices are made, you
can stop the TDM and start the TDS.</p>
</div>
</div>
<div class="sect2">
<h3 id="_very_large_grib_collection_that_changes">Very Large GRIB Collection that changes</h3>
<div class="paragraph">
<p>You have a very large collection which changes, and takes a long time to scan. You must carefully control when/if it will be scanned.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;update startup="never" trigger="allow"/&gt;
&lt;tdm rewrite="test" rescan="0 0 3 * * ? *" /&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The dataset will be read in at startup time by using the existing indexes which must exist. The <a href="TDM.html">TDM</a> will test if its changed once a day
at 3 am, and send a trigger to the TDS if needed.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ncml_modifications">NcML Modifications</h2>
<div class="sectionbody">
<div class="paragraph">
<p>NcML is no longer used to define the collection, but it may still be used to modify the feature collection dataset, for FMRC or Point (not GRIB).</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;featureCollection featureType="FMRC" name="RTOFS Forecast Model Run Collection" path="fmrc/rtofs"&gt;
1) &lt;collection spec="c:/rps/cf/rtofs/.*ofs_atl.*\.grib2$" recheckAfter="10 min" olderThan="5 min"/&gt;

2) &lt;netcdf xmlns="http://www.unidata.ucar.edu/namespaces/netcdf/ncml-2.2"&gt;
    &lt;variable name="time"&gt;
      &lt;attribute name="units" value="hours since 1953-11-29T08:57"/&gt;
     &lt;/variable&gt;
   &lt;/netcdf&gt;

   &lt;protoDataset&gt;
3)  &lt;netcdf xmlns="http://www.unidata.ucar.edu/namespaces/netcdf/ncml-2.2"&gt;
      &lt;attribute name="speech" value="I'd like to thank all the little people..."/&gt;
      &lt;variable name="mixed_layer_depth"&gt;
       &lt;attribute name="long_name" value="mixed_layer_depth @ surface"/&gt;
       &lt;attribute name="units" value="m"/&gt;
      &lt;/variable&gt;
     &lt;/netcdf&gt;
   &lt;/protoDataset&gt;

&lt;/featureCollection&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The collection is defined by a <em>collection</em> element, allowing any number of forecast times per file</p>
</li>
<li>
<p>When you want <em>to modify the component files of the collection</em>, you put an NcML element inside the <em>featureCollection</em> element. This modifies
the component files before they are turned into a gridded dataset. In this case we haved fixed the time coordinate units attribute, otherwise the
individual files would not get recognized as Grid datasets, and the feature collection will fail.</p>
</li>
<li>
<p>When you want <em>to modify the resulting FMRC dataset,</em> you put an NcML element inside the <em>protoDataset</em> element. In this case we have added a
global attribute named <em>speech</em> and 2 attributes on the variable named <em>mixed_layer_depth</em>.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_also_see">Also see:</h4>
<div class="ulist">
<ul>
<li>
<p><a href="FCvsAgg.html">Feature Collections vs Aggregations</a></p>
</li>
</ul>
</div>
<hr>
<div class="paragraph">
<p><span class="image"><img src="../../thread.png" alt="image"></span> This document was last updated August 2015</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2015-09-04 09:42:33 MDT
</div>
</div>
</body>
</html>