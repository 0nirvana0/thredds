<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <title>Server Catalog Spec</title>
  <link href="../tds.css" rel="stylesheet" type="text/css"/>
</head>

<body>
<h1> Server-side Catalog Specification<br/>
</h1>
<hr/>
<p>The
  THREDDS Data Server (TDS) uses specialized catalogs as configuration
  documents. This document specifies the semantics and XML representation of the server-side specializations allowed in THREDDS catalogs. It should be used in conjunction with the <a href="InvCatalogSpec.html">client-side catalog specification</a>.</p>

<h3>Contents:</h3>
<p>Server-side elements described in this document:</p>
<ul>
  <li><a href="#datasetRoot_Element">datasetRoot</a></li>
  <li><a href="#datasetScan_Element">datasetScan</a></li>
</ul>
<p>Also see:</p>
<ul>
  <li><a href="../reference/collections/FeatureCollections.html">featureCollection</a></li>
  <li><a href="http://www.unidata.ucar.edu/schemas/thredds/InvCatalog.1.0.7.xsd">Catalog XML Schema</a><br/>
  </li>
</ul>
<h3><strong>Change History:</strong></h3>
<ul>
  <li>version 1.0.7
    <ul>
      <li>seperate tdm from update element, redo both</li>
      <li>gribConfigType changes (see <a href="../reference/collections/GribConfig.html">here</a> now)</li>
      <li>bring dataFormatTypes and ServiceTypes  up to date</li>
    </ul>
  </li>
  <li>version 1.0.6
    <ul>
      <li>add useRemoteCatalogService attribute on catalogRef</li>
      <li>featureCollection updateType rewrite</li>
      <li>gribConfigType changes</li>
    </ul>
  </li>
  <li>
    version 1.0.5
      <ul>
        <li>updateType.startup is a string to allow &quot;<em>nocheck</em>&quot; value</li>
        <li>add pdsHash to gribConfigType</li>
        <li>add latestNamer, bestNamer, fileSort elements</li>
      </ul>
  </li>
  <li>
    version 1.0.4
      <ul>
        <li>modify featureCollection, epecially gribConfigType</li>
    </ul>
  </li>
  <li>version 1.0.3
    <ul>
      <li>Add featureCollection element</li>
      <li>datasetFMRC is deprecated</li>
    </ul>
  </li>
  <li>
    version 1.0.2
<ul>
      <li>Reorganize addProxies element definition</li>
      <li> add isResolver
        attribute to simpleLatest and latestComplete elements      </li>
      <li>Add datasetFMRC element.  </li>
</ul>
  </li>
</ul>
<hr/>
<h3>The catalog element</h3>
<pre>&lt;xsd:element name=&quot;catalog&quot;&gt;  <br />  &lt;xsd:complexType&gt;<br />    &lt;xsd:sequence&gt;<br />      &lt;xsd:element ref=&quot;service&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;<br />      &lt;xsd:element ref=&quot;datasetRoot&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; /&gt;<br />      &lt;xsd:element ref=&quot;property&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; /&gt;<br />	    &lt;xsd:element ref=&quot;dataset&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot; /&gt;<br />    &lt;/xsd:sequence&gt;<br /><br />    &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; /&gt;<br />    &lt;xsd:attribute name=&quot;expires&quot; type=&quot;dateType&quot;/&gt; <br />    &lt;xsd:attribute name=&quot;version&quot; type=&quot;xsd:token&quot; default=&quot;1.0.2&quot; /&gt; <br />  &lt;/xsd:complexType&gt; <br />&lt;/xsd:element&gt;</pre>
<h3><a name="datasetRoot_Element" id="datasetRoot_Element"></a>The <em>datasetRoot</em> Element<br/>
</h3>
<pre>  &lt;xsd:element name=&quot;datasetRoot&quot;&gt;<br/>    &lt;xsd:complexType&gt;<br/>      &lt;xsd:attribute name=&quot;path&quot; type=&quot;xsd:string&quot; use=&quot;required&quot;/&gt;<br/>      &lt;xsd:attribute name=&quot;location&quot; type=&quot;xsd:string&quot; use=&quot;required&quot;/&gt;<br/>    &lt;/xsd:complexType&gt;<br/>  &lt;/xsd:element&gt;<br/></pre>
<p>The <em>datasetRoot</em> element associates a portion of a URL path with a directory on disk where the data files are stored. <br/>
</p>

<p>Example:<br/>
</p>
<pre>&lt;datasetRoot path=&quot;dsR1&quot; location=&quot;C:/data/mydata/&quot; /&gt;
&lt;datasetRoot path=&quot;dsR1/sub2&quot; location=&quot;Q:/smaug/floober/&quot; /&gt;<br/>...<br/>&lt;dataset name=&quot;dataset1&quot; urlPath=&quot;dsR1/dataset1.nc&quot; /&gt;
&lt;dataset name=&quot;dataset2&quot; urlPath=&quot;dsR1/sub/dataset2.nc&quot; /&gt;
&lt;dataset name=&quot;dataset3&quot; urlPath=&quot;dsR1/sub2/dataset3.nc&quot; /&gt;<br/></pre>
<p>In the catalog, <strong>dataset1</strong> will have URL <strong>dsR1/dataset1.nc</strong> (reletive to the catalog URL), and it will be mapped by the server
  to the file <strong>C:/data/mydata/dataset1.nc</strong>. The <strong>dataset2</strong> has URL <strong>dsR1/sub/dataset2.nc</strong>, and refers to the file
  <strong>C:/data/mydata/sub/dataset2.nc</strong>. The dataset roots are searched for the longest match, so <strong>dataset3</strong> with URL <strong>dsR1/sub2/dataset3.nc</strong>,
  will be matched to the second datasetRoot, and so refers to the file <strong>Q:/smaug/floober/dataset3.nc</strong>.</p>
<hr style="width: 100%; height: 2px;"/>
<p>A <em>datasetScan</em> can be used wherever a dataset element is allowed:</p>

<h3><a name="datasetScan_Element" id="datasetScan_Element"></a><em>The datasetScan</em> Element</h3>
<pre>&lt;xsd:element name=&quot;datasetScan&quot; substitutionGroup=&quot;dataset&quot;&gt;<br/>  &lt;xsd:complexType&gt;<br/>    &lt;xsd:complexContent&gt;<br/>      &lt;xsd:extension base=&quot;DatasetType&quot;&gt;<br/>        &lt;xsd:sequence&gt;<br/>          &lt;xsd:element ref=&quot;filter&quot; minOccurs=&quot;0&quot; /&gt;<br/>          &lt;xsd:element ref=&quot;addID&quot; minOccurs=&quot;0&quot; /&gt;<br/>          &lt;xsd:element ref=&quot;namer&quot; minOccurs=&quot;0&quot; /&gt;<br/>          &lt;xsd:element ref=&quot;sort&quot; minOccurs=&quot;0&quot; /&gt;<br/>          &lt;xsd:element ref=&quot;addLatest&quot; minOccurs=&quot;0&quot; /&gt;<br/>          &lt;xsd:element ref=&quot;addProxies&quot; minOccurs=&quot;0&quot; /&gt;<br/>          &lt;xsd:element name=&quot;addDatasetSize&quot; minOccurs=&quot;0&quot; /&gt;<br/>          &lt;xsd:element ref=&quot;addTimeCoverage&quot; minOccurs=&quot;0&quot; /&gt;<br/>        &lt;/xsd:sequence&gt;<br/><br/>        &lt;xsd:attribute name=&quot;path&quot; type=&quot;xsd:string&quot; use=&quot;required&quot;/&gt;<br/>        &lt;xsd:attribute name=&quot;location&quot; type=&quot;xsd:string&quot;/&gt;<br/>      &lt;/xsd:extension&gt;<br/>    &lt;/xsd:complexContent&gt;<br/>  &lt;/xsd:complexType&gt;<br/>&lt;/xsd:element&gt;</pre>
<p>The <em>datasetScan</em> element generates nested THREDDS catalogs by scanning the directory named in the <em>location</em> attribute, and creating a
  <em>dataset</em> for each file found, and a <em>catalogRef</em> for each subdirectory. The <em>path</em> attribute is used to create the URL for these files and
  catalogs. <br/>
</p>

<p>A <em>datasetScan</em> element is in the dataset substitutionGroup, so it can
  be used wherever a <em><a href="InvCatalogSpec.html#dataset">dataset</a></em> element can be used. It is
  an extension of a
  DatasetType, so any of dataset's nested elements and attributes can be
  used in it. This allows you to add enhanced metadata to a datasetScan.
  However you should not add nested datasets, as these will be ignored. </p>

<p>Each generated catalog will include all datasets at the
  requested level of the given dataset collection location. Each
  collection (directory) dataset will be included as a <em>catalogRef</em> element and each atomic (file) dataset will be included as a <em>dataset</em> element.
  The name of the resulting <em>dataset</em> or <em>catalogRef</em> will be the name of the corresponding dataset. No metadata will be added other than that
  contained in the <em>datasetScan</em> element which will be added as appropriate at the different level of
  the given dataset collection location depending on if it is inherited
  metadata or not.<br/>
</p>

<p>The <em>datasetScan</em> specific nested elements (<a href="#filter_Element">filter</a>, <a href="#addID_Element">addID</a>, <a href="#namer_Element">namer</a>,
  <a href="#sort_Element">sort</a>, <a href="#addLatest_Element">addLatest</a>, <a href="#addProxies_Element">addProxies</a>, <a href="#addDatasetSizeElement">addDatasetSize</a>,
  and <a href="#addTimeCoverage_Element">addTimeCoverage</a>) can be used to modify the default behavior or add metadata.<br/>
</p>

<p>Here is a very simple example: </p>
<pre>
&lt;datasetScan name=&quot;GRIB2 Data&quot; path=&quot;grib2&quot; location=&quot;C:/data/grib2/&quot; &gt;
  &lt;dataFormat&gt;GRIB-2&lt;/dataFormat&gt;
&lt;/datasetScan &gt;
</pre>
<p>The client view of the given datasetScan element would look like:<br/>
</p>
<pre>
&lt;catalogRef name=&quot;&quot; xlink:href=&quot;/thredds/catalog/grib2/catalog.xml&quot; xlink:title=&quot;GRIB2 Data&quot; /&gt;
</pre>
<p>If the <code>grib2</code> directory contained three files (<code>data1.wmo</code>, <code>data2.wmo</code>, and <code>readme.txt</code>) and one directory
  (<code>test</code>), the catalog at the URL given in the above <span style="font-style: italic;">xlink:href</span> attribute would look something like:<br/>
</p>
<pre>
&lt;catalog ...&gt;
  &lt;service name=&quot;myserv&quot; ... /&gt;
  &lt;dataset name=&quot;GRIB2 Data&quot;&gt;
    &lt;metadata inherited=&quot;true&quot;&gt;
      &lt;serviceName&gt;myserv&lt;/serviceName&gt;
    &lt;/metadata&gt;
    &lt;dataset name=&quot;data1.wmo&quot; urlPath=&quot;grib2/data1.wmo&quot; /&gt;
    &lt;dataset name=&quot;data2.wmo&quot; urlPath=&quot;grib2/data2.wmo&quot; /&gt;
    &lt;dataset name=&quot;readme.txt&quot; urlPath=&quot;grib2/readme.txt&quot; /&gt;
    &lt;catalogRef xlink:title=&quot;test&quot; xlink:href=&quot;test/catalog.xml&quot; name=&quot;&quot; /&gt;
  &lt;/dataset&gt;
&lt;/catalog&gt;
</pre>
<h3><a name="filter_Element" id="filter_Element"></a>filter Element<br/>
</h3>
<pre>&lt;xsd:element name=&quot;filter&quot;&gt;<br/>  &lt;xsd:complexType&gt;<br/>    &lt;xsd:choice&gt;<br/>      &lt;xsd:sequence minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;<br/>        &lt;xsd:element name=&quot;include&quot; type=&quot;FilterSelectorType&quot; minOccurs=&quot;0&quot;/&gt;<br/>        &lt;xsd:element name=&quot;exclude&quot; type=&quot;FilterSelectorType&quot; minOccurs=&quot;0&quot;/&gt;<br/>      &lt;/xsd:sequence&gt;<br/>    &lt;/xsd:choice&gt;<br/>  &lt;/xsd:complexType&gt;<br/>&lt;/xsd:element&gt;<br/><br/>&lt;xsd:complexType name=&quot;FilterSelectorType&quot;&gt;<br/>  &lt;xsd:attribute name=&quot;regExp&quot; type=&quot;xsd:string&quot;/&gt;<br/>  &lt;xsd:attribute name=&quot;wildcard&quot; type=&quot;xsd:string&quot;/&gt;<br/>  &lt;xsd:attribute name=&quot;atomic&quot; type=&quot;xsd:boolean&quot;/&gt;<br/>  &lt;xsd:attribute name=&quot;collection&quot; type=&quot;xsd:boolean&quot;/&gt;<br/>&lt;/xsd:complexType&gt;<br/>
</pre>
<p>The <em>filter</em> element allows users to specify which datasets are
  to be included in the generated catalogs. A filter element can contain
  any number of <em>include</em> and <em>exclude</em> elements. Each <em>include</em> or <em>exclude</em> element may contain either a <em>wildcard</em> or a
  <em>regExp</em> attribute. If the given wildcard pattern or <a href="http://www.regular-expressions.info/">regular expression</a> matches a dataset name, that
  dataset is included or excluded as
  specified. By default, includes and excludes apply only to atomic
  datasets (regular files). You can specify that they apply to atomic
  and/or collection datasets (directories) by using the <em>atomic</em> and <em>collection</em> attributes.<br/>
</p>

<p>Expanding on the above example: </p>
<pre>&lt;datasetScan name=&quot;GRIB2 Data&quot; path=&quot;grib2&quot; location=&quot;C:/data/grib2/&quot; &gt;<br/>  &lt;dataFormat&gt;GRIB-2&lt;/dataFormat&gt;<br/>  &lt;filter&gt;<br/>    &lt;include wildcard=&quot;*.wmo&quot; /&gt;<br/>  &lt;/filter&gt;<br/>&lt;/datasetScan &gt;<br/></pre>
results in:<br/>
<pre>&lt;catalog ...&gt;<br/>  &lt;service name=&quot;myserv&quot; ... /&gt;<br/>  &lt;dataset name=&quot;GRIB2 Data&quot;&gt;<br/>    &lt;metadata inherited=&quot;true&quot;&gt;&lt;serviceName&gt;myserv&lt;/serviceName&gt;&lt;/metadata&gt;<br/>    &lt;dataset name=&quot;data1.wmo&quot; urlPath=&quot;data1.wmo&quot; /&gt;<br/>    &lt;dataset name=&quot;data2.wmo&quot; urlPath=&quot;data2.wmo&quot; /&gt;<br/>  &lt;/dataset&gt;<br/>&lt;/catalog&gt;<br/></pre>
<p>More examples are available in the <a href="../reference/DatasetScan.html#Including_Only_the_Desired_Files">TDS datasetsScan documentation</a>.<br/>
</p>

<h3><a name="addID_Element" id="addID_Element"></a>addID Element<br/>
</h3>
<pre>&lt;xsd:element name=&quot;addID&quot; /&gt;<br/></pre>
<p>The <em>addID</em> element specifies that a datasetScan should add an <em>ID</em> attribute to each <em>dataset</em> element included in a resulting catalog.<br/>
</p>

<p>The TDS adds ID attributes by default even if no addID element is
  given in the datasetScan. The IDs are constructed by concatenating the
  relative path of the generated dataset to either the datasetScan
  ID (if it exists) or the datasetScan path.<br/>
</p>

<p>So the example results from the filter section above would more accurately be:<br/>
</p>
<pre>&lt;catalog ...&gt;<br/>  &lt;service name=&quot;myserv&quot; ... /&gt;<br/>  &lt;dataset name=&quot;GRIB2 Data&quot; ID=&quot;grib2&quot;&gt;<br/>    &lt;metadata inherited=&quot;true&quot;&gt;&lt;serviceName&gt;myserv&lt;/serviceName&gt;&lt;/metadata&gt;<br/>    &lt;dataset name=&quot;data1.wmo&quot; ID=&quot;grib2/data1.wmo&quot; urlPath=&quot;data1.wmo&quot; /&gt;<br/>    &lt;dataset name=&quot;data2.wmo&quot; ID=&quot;grib2/data2.wmo&quot; urlPath=&quot;data2.wmo&quot; /&gt;<br/>  &lt;/dataset&gt;<br/>&lt;/catalog&gt;</pre>
<h3><a name="namer_Element" id="namer_Element"></a>namer Element<br/>
</h3>
<pre>&lt;xsd:element name=&quot;namer&quot;&gt;<br/>  &lt;xsd:complexType&gt;<br/>    &lt;xsd:choice maxOccurs=&quot;unbounded&quot;&gt;<br/>      &lt;xsd:element name=&quot;regExpOnName&quot; type=&quot;NamerSelectorType&quot;/&gt;<br/>      &lt;xsd:element name=&quot;regExpOnPath&quot; type=&quot;NamerSelectorType&quot;/&gt;<br/>    &lt;/xsd:choice&gt;<br/>  &lt;/xsd:complexType&gt;<br/>&lt;/xsd:element&gt;<br/></pre>
<pre>&lt;xsd:complexType name=&quot;NamerSelectorType&quot;&gt;<br/>  &lt;xsd:attribute name=&quot;regExp&quot; type=&quot;xsd:string&quot;/&gt;<br/>  &lt;xsd:attribute name=&quot;replaceString&quot; type=&quot;xsd:string&quot;/&gt;<br/>&lt;/xsd:complexType&gt;<br/></pre>
<p>The <em>namer</em> element specifies one or more methods for renaming resulting <em>dataset</em> and <em>catalogRef</em> elements. Currently, two methods for
  renaming are available. Both methods use <a href="http://www.regular-expressions.info/">regular expression</a> matching and
  <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/regex/Pattern.html#cg">capturing group</a> replacement to determine the new
  name. The first method, specified by the <em>regExpOnName</em> element, does regular
  expression matching on the dataset name. The second method, specified by the <em>regExpOnPath</em> element, does regular expression matching on the entire
  dataset path. In either method, the <em>regExp</em> attribute contains the regular expression used in matching on the name or path and the <em>replaceString</em>
  attribute contains the replacement string on which capturing group replacement is performed.<br/>
</p>

<p>A capturing group is a part of a regular expression enclosed in
  parenthesis. When a regular expression with a capturing group is
  applied to a string, the substring that matches the capturing group is
  saved for later use. The captured strings can then be substituted into
  another string in place of capturing group references,&quot;$n&quot;, where &quot;n&quot;
  is an integer indicating a particular capturing group. (The capturing
  groups are numbered according to the order in which they appear in the
  match string.) For example, the regular expression &quot;Hi (.*), how are
  (.*)?&quot; when applied to the
  string &quot;Hi Fred, how are you?&quot; would capture the strings &quot;Fred&quot; and
  &quot;you&quot;. Following that with a capturing group replacement in the string
  &quot;$2 are $1.&quot; would result in the string &quot;you are Fred.&quot;</p>

<p>Here's an example namer:</p>
<pre>&lt;namer&gt;<br/>  &lt;regExpOnName regExp=&quot;([0-9]{4})([0-9]{2})([0-9]{2})_([0-9]{2})([0-9]{2})&quot;<br/>                replaceString=&quot;NCEP GFS 191km Alaska $1-$2-$3 $4:$5:00 GMT&quot;/&gt;<br/>&lt;/namer</pre>
<p>the regular expression has five capturing groups</p>
<ol>
  <li>The first capturing group, &quot;([0-9]{4})&quot;,&nbsp; captures four digits, in this case the year.<br/>
  </li>
  <li>The second capturing group, &quot;([0-9]{2})&quot;, captures two digits, in this case the month.<br/>
  </li>
  <li>The third capturing group, &quot;([0-9]{2})&quot;, captures two digits, in this case the day of the month.<br/>
  </li>
  <li>The fourth capturing group, &quot;([0-9]{2})&quot;, captures two digits, in this case the hour of the day.</li>
  <li>The fifth capturing group, &quot;([0-9]{2})&quot;, captures two digits, in this case the minutes of the hour.</li>
</ol>
When applied to the dataset name
&quot;GFS_Alaska_191km_20051011_0000.grib1&quot;,&nbsp; the
strings
&quot;2005&quot;, &quot;10&quot;, &quot;11&quot;, &quot;00&quot;, and &quot;00&quot; are captured. After replacing the
capturing group references in the replaceString attribute value, we get
the name &quot;NCEP GFS 191km Alaska 2005-10-11 00:00:00 GMT&quot;.
So, when cataloged, this dataset would end up as something like this:<br/>
<pre>&lt;dataset name=&quot;NCEP GFS 191km Alaska 2005-10-11 00:00:00 GMT&quot;<br/>        &nbsp;urlPath=&quot;models/NCEP/GFS/Alaska_191km/GFS_Alaska_191km_20051011_0000.grib1&quot;/&gt;</pre>
<h3><a name="sort_Element" id="sort_Element"></a>sort Element<br/>
</h3>
<pre>&lt;xsd:element name=&quot;sort&quot;&gt;<br/>  &lt;xsd:complexType&gt;<br/>    &lt;xsd:choice&gt;<br/>      &lt;xsd:element name=&quot;lexigraphicByName&quot;&gt;<br/>        &lt;xsd:complexType&gt;<br/>          &lt;xsd:attribute name=&quot;increasing&quot; type=&quot;xsd:boolean&quot;/&gt;<br/>        &lt;/xsd:complexType&gt;<br/>      &lt;/xsd:element&gt;<br/>    &lt;/xsd:choice&gt;<br/>  &lt;/xsd:complexType&gt;<br/>&lt;/xsd:element&gt;<br/>
</pre>
<p>Without a <em>sort</em> element, datasets at each collection level are listed
  in their &quot;natural&quot; order. The <em>sort</em> element specifies how to order&nbsp; those datasets. Currently, a <em>sort</em> element can only contain one
  <em>lexigraphicByName</em> element which indicates that datasets should be ordered lexigraphically according to the dataset name. The <em>increasing</em>
  attribute in the <em>lexigraphicByName</em> element indicates whether the datasets should in increasing or decreasing order.</p>

<h3><a id="addLatest_Element"></a>addLatest Element<br/>
</h3>
<pre>&lt;xsd:element name=&quot;addLatest&quot;&gt;<br/>  &lt;xsd:complexType&gt;<br/>    &lt;xsd:sequence&gt;<br/>      &lt;xsd:element name=&quot;simpleLatest&quot; minOccurs=&quot;0&quot;&gt;<br/>        &lt;xsd:complexType&gt;<br/>          &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot;/&gt;<br/>          &lt;xsd:attribute name=&quot;top&quot; type=&quot;xsd:boolean&quot;/&gt;<br/>          &lt;xsd:attribute name=&quot;serviceName&quot; type=&quot;xsd:string&quot;/&gt;<br/>        &lt;/xsd:complexType&gt;<br/>      &lt;/xsd:element&gt;<br/>    &lt;/xsd:sequence&gt;<br/>  &lt;/xsd:complexType&gt;<br/>&lt;/xsd:element&gt;<br/>
</pre>
<p>The <em>addLatest</em> element is deprecated in favor of the <em>addProxies</em> element.</p>

<h3><a name="addProxies_Element" id="addProxies_Element"></a>addProxies Element<br/>
</h3>
<pre>&lt;xsd:element name=&quot;addProxies&quot;&gt;<br/>  &lt;xsd:complexType&gt;<br/>    &lt;xsd:sequence&gt;<br/>      &lt;xsd:element name=&quot;simpleLatest&quot; minOccurs=&quot;0&quot;&gt;<br/>        &lt;xsd:complexType&gt;<br/>          &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot;/&gt;<br/>          &lt;xsd:attribute name=&quot;top&quot; type=&quot;xsd:boolean&quot;/&gt;<br/>          &lt;xsd:attribute name=&quot;serviceName&quot; type=&quot;xsd:string&quot;/&gt;<br/>        &lt;/xsd:complexType&gt;<br/>      &lt;/xsd:element&gt;<br/>      &lt;xsd:element name=&quot;latestComplete&quot; minOccurs=&quot;0&quot;&gt;<br/>        &lt;xsd:complexType&gt;<br/>          &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot;/&gt;<br/>          &lt;xsd:attribute name=&quot;top&quot; type=&quot;xsd:boolean&quot;/&gt;<br/>          &lt;xsd:attribute name=&quot;serviceName&quot; type=&quot;xsd:string&quot;/&gt;<br/>          &lt;xsd:attribute name=&quot;lastModifiedLimit&quot; type=&quot;xsd:float&quot;/&gt;<br/>        &lt;/xsd:complexType&gt;<br/>      &lt;/xsd:element&gt;<br/>    &lt;/xsd:sequence&gt;<br/>  &lt;/xsd:complexType&gt;<br/>&lt;/xsd:element&gt;<br/>
</pre>
<p>The <em>addProxies</em> element<strong></strong> provides a place for
  describing proxy datasets to be added to each collection
  dataset under a datasetScan.<br/>
</p>

<p>Currently, two types of proxy datasets
  are supported. They are both intended to proxy the &quot;latest&quot; dataset in
  the scanned collection. The first type of proxy dataset, specified by
  the <em>simpleLatest</em> element, adds a dataset that proxies the existing dataset whose name is
  lexigraphically greatest. This dataset will be the &quot;latest&quot; if the
  dataset name contains a timestamp. The <em>simpleLatest</em> element may contain a <em>name</em> attribute which is used as the name of the proxy dataset, the <em>serviceName</em>
  attribute that references the <em>service</em> element that is to be referenced by the resulting proxy dataset, and the <em>top</em> attribute which indicates if
  the proxy dataset should appear at the top
  or bottom of the list of dataset in this collection. Default behavior
  in the TDS if any these attributes are missing is to name the dataset
  &quot;latest.xml&quot;, reference the &quot;latest&quot; service, and place the dataset at
  the top of the collection.<br/>
</p>

<p>The second type of proxy dataset, specified by the <em>latestComplete</em> element, is the same as the simple latest except that it will exclude
  any dataset that was last modified within the number of minutes
  specified by the <em>lastModifedLimit</em> attribute. It must contain all the attributes allowed in the <em>simpleLatest</em> element plus the <em>lastModifiedLimit</em>
  attribute.<br/>
</p>

<p>An example is available in the <a href="../reference/DatasetScan.html#Adding_Proxy_Datasets">TDS datasetsScan documentation</a>.</p>

<h3><a name="addTimeCoverage_Element" id="addTimeCoverage_Element"></a>addTimeCoverage Element<br/>
</h3>
<pre>  &lt;xsd:element name=&quot;addTimeCoverage&quot;&gt;<br/>    &lt;xsd:complexType&gt;<br/>      &lt;xsd:attribute name=&quot;datasetNameMatchPattern&quot; type=&quot;xsd:string&quot;/&gt;<br/>      &lt;xsd:attribute name=&quot;datasetPathMatchPattern&quot; type=&quot;xsd:string&quot;/&gt;<br/>      &lt;xsd:attribute name=&quot;startTimeSubstitutionPattern&quot; type=&quot;xsd:string&quot;/&gt;<br/>      &lt;xsd:attribute name=&quot;duration&quot; type=&quot;xsd:string&quot;/&gt;<br/>    &lt;/xsd:complexType&gt;<br/>  &lt;/xsd:element&gt;<br/>
</pre>
<p>The <em>addTimeCoverage</em> element indicatest that a THREDDS <em>timeCoverage</em> element should be added to each atomic dataset cataloged by the containing
  <em>datasetScan</em> element and describes how to determine the time coverage for each datasets in the collection.<br/>
</p>

<p>Currently, the <em>addTimeCoverage</em> element can only describe one method for determining the time coverage of a dataset. The&nbsp; <em>datasetNameMatchPattern</em>
  attribute is used in a regular expression match on the dataset name. If
  the match succeeds, a capturing group replacement is performed on the <em>startTimeSubstitutionPattern</em> attribute and the result is the start time string
  (see the <em>namer</em> element description, <a href="#namer_Element">above</a>, for more on regular expressions and capturing groups). The time coverage
  duration is given by the <em>duration</em> attribute.</p>

<p>The <span style="font-style: italic;">datasetPathMatchPattern</span> attribute was added (2009-06-05, TDS 4.0) to allow matching on the
  entire dataset path instead of just the dataset name. The two match
  pattern attributes should not be used together; if they are both given
  the <span style="font-style: italic;">datasetNameMatchPattern</span> will be used.<br/>
</p>

<p>Example:<br/>
</p>
<pre>  &lt;datasetScan name=&quot;My Data&quot; path=&quot;myData&quot; location=&quot;c:/my/data/&quot;&gt; <br/>    &lt;serviceName&gt;myserver&lt;/serviceName&gt;<br/>    &lt;addTimeCoverage datasetNameMatchPattern=&quot;([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})_gfs_211.nc$&quot;<br/>                     startTimeSubstitutionPattern=&quot;$1-$2-$3T$4:00:00&quot;<br/>                     duration=&quot;60 hours&quot; /&gt;<br/>  &lt;/datasetScan&gt;<br/>
</pre>
<p>for the dataset named &quot;2005071812_gfs_211.nc&quot;, results in the following timeCoverage element:<br/>
</p>
<pre>  &lt;timeCoverage&gt;<br/>    &lt;start&gt;2005-07-18T12:00:00&lt;/start&gt;<br/>    &lt;duration&gt;60 hours&lt;/duration&gt;<br/>  &lt;/timeCoverage&gt;<br/>
</pre>
<h3><a name="addDatasetSizeElement" id="addDatasetSizeElement"></a>addDatasetSizeElement</h3>
<pre>  &lt;xsd:element name=&quot;addDatasetSize&quot; /&gt;</pre>
<p>The addDatasetSize element indicates that file size metadata in the form of a <em>dataSize</em> element should be added to all atomic datasets.<br/>
</p>

<p>An example is available in the <a href="../reference/DatasetScan.html#Adding_Dataset_Size_Information">TDS datasetsScan documentation</a>.</p>
<hr/>
<h2>Index<a name="index" id="index"></a></h2>
<ul>
  <li><a href="#addID_Element">addID</a>: an element<br/>
  </li>
  <li><a href="#addLatest_Element">addLatest</a>: an element</li>
  <li><a href="#addProxies_Element">addProxies</a>: an element<br/>
  </li>
  <li><a href="#addTimeCoverage_Element">addTimeCoverage</a>: an element<br/>
  </li>
  <li><a href="#datasetScan_Element">datasetScan</a>: an element which creates nested catalogs by scanning directories.</li>
  <li><a href="#datasetRoot_Element">datasetRoot</a>: an element which associates a local disk directory with a URL path<br/>
  </li>
  <li><a href="#filter_Element">filter</a>: an element</li>
  <li><a href="#namer_Element">namer</a>: an element<br/>
  </li>
  <li><a href="#sort_Element">sort</a>: an element</li>
</ul>
<hr/>
<p><img alt="THREDDS" src="../thread.png" height="108" width="110" />This document is maintained by Unidata and was
  last updated January 2015. Send comments to <a href="mailto:support-thredds@unidata.ucar.edu">THREDDS
support</a>. </p>

</body>
</html>
