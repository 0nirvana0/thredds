= NcStream Data Col-oriented (version 2)
[[threddsDocs]]

* This documents version 2 of the NcStream Data message, used by CDM/TDS >= 5.0.
* This is the "column oriented" variant.
* Leaving out compression for now.

== Grammer

----
data2Message := MAGIC_DATA2, vlenb, NcStreamProto.Data2

vlenb := variable length encoded positive integer == length of the following object in bytes
NcStreamProto.Data2 := Data message encoded by protobuf
----

== NcStreamProto.Data2

----
message Data2 {
  string fullName = 1;
  DataType dataType = 2;
  Section section = 3;
  bool bigend = 4;
  uint32 version = 5;
  bool isVlen = 7;
  uint32 nelems = 9;

  bytes primdata = 10;              // rectangular, primitive array # <1>
  repeated string stringdata = 11;  // string dataType # <2>
  repeated uint32 vlens = 12;      // isVlen true # <3>
  repeated bytes opaquedata = 13;   // opaque dataTypes # <4>
  ArrayStructureCol structdata = 14;// structure/seq dataType
}

message ArrayStructureDataCol {
  repeated Data2 memberData = 1;
}
----

<1> *primdata* has _nelems_ * sizeof(dataType) bytes, turn into multidim array of primitives with section info and bigend
<2> *stringdata* has _nelems_ strings, turn into multidim array of String with section info
<3> *vlens* has _section.size_ array lengths; section does not include the last (vlen) dimension; data in primdata
<4> *opaquedata* has _nelems_ opaque objects, turn into multidim array of Opaque with section info
<5> *structdata* has _nelems_ StructureData objects, turn into multidim array of StructureData with section info and bigend

=== Arrays of primitive data

* For all primitive data types, specified by _dataType_, with _isVlen_=false.
* The data is laid out in row-major order in _primarry_.
* The number of elements is _nelems_.
* The shape of the Array is specified by _section_.
* Endianness is specified by _bigend_. This is _reader-make-right_.

=== Arrays of string

* For data type = STRING.
* The data is laid out in row-major order in _stringdata_.
* The number of elements is _nelems_.
* The shape of the Array is specified by _section_.
* String data is always UTF-8 encoded.

=== Arrays of opaque

* For data type = OPAQUE.
* The data is laid out in row-major order in _opaquedata_.
* The number of elements is _nelems_.
* The shape of the Array is specified by _section_.
* Opague data are variable length of bytes, aka blobs.

=== Vlen

Variable-length data can only have a variable length in its innermost (fastest varying) dimension, so it has the form:

----
  dataType varname(d1,d2,di,*);

  where
    d1,d2,di are 0 or more fixel length dimensions; this is the data's "fixed shape".
    * is the last, variable-length dimension.
----

* For _isVlen_ = true.
* The data is laid out in row-major order in _primdata_, _stringdata_, or _opaquedata_, depending on the _dataType_.
* The total number of elements in the data array is _nelems_.
* The fixed shape of the data is specified by _section_.
* The length of each variable-length array is stored in _vlens_. There will be _shape.size()_ of them.
* The sum of the _vlens_ is equal to _nelems_.
* see link:../../CDM/VariableLengthData.adoc[vlen data]

Examples:

. when encoding, the length of each vlen is known, so:
.. _float vlen(*)_ will have a known length, so can be encoded the same as a regular array
.. _float vlen(3,7, *)_ has 21 variable length arrays, stored in the vlens array
... *primdata* has nelems * sizeof(dataType) bytes, turn into dim array of primitives, use vlens to divide into variable length arrays


=== Structures

* For data type = STRUCTURE.
* The data is stored seperately for each member in _ArrayStructureDataCol_. This is called _column oriented_ storage.
* The number of rows in the Structure is _nelems_.
* The shape of the array of Structures is specified by _section_, where _section.size()_ == nelems.

For each Structure Member:

* Each member has a _Data2_ message in the _ArrayStructureDataCol.memberData_.
* The member _dataType_ is arbitrary, including nested Structures.
* The member _section_ describes the shape of the entire data array, including parent Structures (see Nested Structures below).
* The data is stored exactly the same as in top-level _Data2_ messages.

=== Nested Structures

A nested structure like

----
Structure {
  int fld1
  string fld2(12);
  Structure {
    float fld3;
    long fld4(2,3);
  } inner(99)
} s(123)
----

can be encoded like:

----
  int s.fld1(123)
  string s.fld2(123, 12);
  float s.inner.fld3(123,99);
  long s.inner.fld4(123,99,2,3);
----

* The shape of member data includes the outer structure(s).
* All of the data resides at the innermost Structure.

==== Vlens inside of structures

These can only make other vlens (last dimension a vlen):

----
Structure {
  int fld1
  string fld2(*);
  Structure {
    float fld3;
    long fld4(2,*);
  } inner(99)
} s(33)
----

makes:

----
  int s.fld1(33)
  string s.fld2(33,*);
  float s.inner.fld3(33,99);
  long s.inner.fld4(33,99,2,*);
----

so these are coded just like vlens in the innermost Structure, with a fixed shape including any parent Structures.

== Nested sequences

An outer sequence is not a problem

----
Sequence {
  int fld1
  string fld2(12);
  Structure {
    float fld3;
    long fld4(2,3);
  } inner(99)
} seq;
----

Because when writing the data, the actual number sent over the wire will be known.

The problem comes with nested sequences:

----
Structure {
  int fld1
  string fld2(*);
  Sequence {
    float fld3;
    long fld4(2,*);
  } seq;
} s(33)
----

which gives in the innermost nested structures:

----
  int s.fld1(33)
  string s.fld2(33,*);
  float s.inner.fld3(33,*);
  long s.inner.fld4(33,*,2,*);
----

The idea is that the _vlens_ array is a listing of the lengths needed, it takes the place of (33,*), and tells the reader
how to divide up the nelems flds:

----
  int s.fld1(33)
  string s.fld2(33,*);
  float s.inner.fld3(nelems);
  long s.inner.fld4(nelems,2,*);
----

The _s.seq_ Data2 will look like:

----
message Data2 {
  string fullName = "seq"
  DataType dataType = SEQUENCE
  Section section = null;
  bool isVlen = "true";
  uint32 nelems = sum of vlens

  bytes primdata = null
  repeated string null
  repeated uint32 vlens = size: 33
  repeated bytes opaquedata = null;
  ArrayStructureCol structdata = present
}
----

Assume for this example that the sum of vlens = 6789

The _s.seq.fld2_ Data2 will look like:

----
message Data2 {
  string fullName = "fld2"
  DataType dataType = FLOAT
  Section section = (6738);
  bool isVlen = "false";
  uint32 nelems = 6738

  bytes primdata = 6738 floats
  repeated string null
  repeated uint32 vlens = null
  repeated bytes opaquedata = null;
  ArrayStructureCol structdata = null
}
----

The _s.seq.fld4_ Data2 will look like:

----
message Data2 {
  string fullName = "fld4"
  DataType dataType = LONG
  Section section = (6738,2);
  bool isVlen = "true";
  uint32 nelems = sum of vlens

  bytes primdata = nelems longs
  repeated string null
  repeated uint32 vlens = size: 6738*2
  repeated bytes opaquedata = null;
  ArrayStructureCol structdata = null
}
----

The reader uses seq _s.seq.vlens_ to allocate the 6738 values into 33 variable length arrays of Structure objects.

