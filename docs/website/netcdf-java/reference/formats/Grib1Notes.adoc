:source-highlighter: coderay
[[threddsDocs]]

= CDM GRIB-1 Notes

== ECMWF extended complex packing

ECMWF uses an undocumented format for *_GRIB-1 extended complex packing_*.
As a service to the community, we document here that format as well as we understand it.

When should this format be used? There is a standard WMO complex_packing (though I havent seen it used), so probably
best to restrict to center = ECMWF. The flag at octet 4 is tested for _isGridPointData_ (bit 1 = 0) and _isComplexPacking_ (bit 2 = 1).

Sources:

* *_GRIB-API_* source code _data.grid_second_order.def_

[title="Section-4 (BDS)",width="100%",cols="10%,90%",options="header",]
|===
|Octet|Content
|1-3 |*_dataMessageLength_*: Length in octets of binary data section
|4 | *_flag_*: Bits 1 through 4: See Table 11, and note 5 below +
*_unusedBits_*: Bits 5 through 8: Number of unused bits at end of Section 4.
|5-6 | *_binaryScaleFactor_*: The binary scale factor.
|7-10 | *_referenceValue_*: Reference value.
|11 |*_widthOfFirstOrderValues_*, number of bits of first order packed values.
|12-13 |*_N1_* - Octet number relative to the start of the BDS, at which the first order packed numbers begin.
|14 | *_extendedFlags_*: See Code Table 11-2, below.
|15-16 |*_N2_* - Octet number relative to the start of the BDS, at which the second order packed numbers begin.
|17-18 |*_codedNumberOfGroups_* : see Note 1
|19-20 |*_numberOfSecondOrderPackedValues_* - The number of second order packed values : see Notes 2, 3
|21 | *_extraValues_* : see Note 1
|22 | *_widthOfWidths_* : width in bits of groupWidths
|23 | *_widthOfLengths_* : width in bits of groupLengths
|24-25 | *_NL_* - Octet number relative to the start of the BDS, at which the group lengths begin
|26-(NL-1)| packed *_groupWidths_*: _widthOfWidths*numberOfGroups_ bits, 0 padded to end of byte
|NL-(N1-1)| packed *_groupLengths_*: _widthOfLengths*numberOfGroups_ bits, 0 padded to end of byte
|N1-(N2-1)| packed *_firstOrderValues_*: _widthOfFirstOrderValues*numberOfGroups_ bits, 0 padded to end of byte
|N2-... | packed *_secondOrderValues_*: _sum(groupLength[group] * groupWidth[group])_ bits
|===

*_Table 11-2_*: From http://cost733.geo.uni-augsburg.de/cost733class-1.2/browser/grib_api-1.9.18/definitions/grib1/11-2.table?rev=4:
----
# CODE TABLE 11-2, Flag
#  Undocumented use of octet 14 extendedFlags
#  Taken from d2ordr.F
#         R------- only bit 1 is reserved.
#         -0------ single datum at each grid point.
#         -1------ matrix of values at each grid point.
#         --0----- no secondary bit map.
#         --1----- secondary bit map present.
#         ---0---- second order values have constant width.
#         ---1---- second order values have different widths.
#         ----0--- no general extended second order packing.
#         ----1--- general extended second order packing used.
#         -----0-- standard field ordering in section 4.
#         -----1-- boustrophedonic ordering in section 4.
1 0 Reserved
1 1 Reserved
2 0 Single datum at each grid point
2 1 Matrix of values at each grid point
3 0 No secondary bitmap Present
3 1 Secondary bitmap Present
4 0 Second-order values constant width
4 1 Second-order values different widths
5 0 no general extended second order packing
5 1 general extended second order packing used
6 0 standard field ordering in section 4
6 1 boustrophedonic ordering in section 4
#         ------00 no spatial differencing used.
#         ------01 1st-order spatial differencing used.
#         ------10 2nd-order    "         "         " .
#         ------11 3rd-order    "         "         " .
----

Notes:

. *_numberOfGroups_* = _codedNumberOfGroups + 65536 * extraValues_
. with only two bytes, _numberOfSecondOrderPackedValues_ has maximum of 65536; so 65536 indicates overflow
.  *_numberOfSecondOrderPackedValues_* can be calculated as _sum(groupLengths)_. This should match npts from GDS.
. if groupWidth == 0, secondOrderValue = 0 for all values in that group
. The flag at octet 4 is tested for _isGridPointData_ (bit 1 = 0) and _isComplexPacking_ (bit 2 = 1). Otherwise, not used.

The floating point calculation of a value is:

[source,java]
----
double pow10 =  Math.pow(10.0, -pds.decimalScale); // from PDS section
float ref = (float) (pow10 * referenceValue);
float scale = (float) (pow10 * Math.pow(2.0, binaryScaleFactor));
int val = 0;
for (int group = 0; group < numberOfGroups; group++) {
  for (int i = 0; i < groupLength[group]; i++) {
    values[val] = ref + scale * (firstOrderValues[group] + secondOrderValues[val]);
    val++;
  }
}
----

== Problems

This algorithm is not yet correct, at least on the sample message.

. After reading the groupWidths (_widthOfWidths*numberOfGroups_ bits), we are at byte 2059, but should be at NL=2066.
. The calculation of total number of points _sum(groupLength[group])_ = 88836, but npts from GDS (this is a gaussian grid) = 88838.
. The calculation of secondOrderValues _sum(groupLength[group] * groupWidth[group])_ bits = 585395, nbytes=73175,
but we dont have that many bytes in the data message.

So we dont quite have it right.

